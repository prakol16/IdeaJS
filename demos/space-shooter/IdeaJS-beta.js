// Generated by CoffeeScript 1.6.3
/*
Author: Praneeth Kolichala
Copyright (c) unofficially 2012-2013
Version: Beta 1.0.0
*/


(function() {
  "use strict";
  var $, GetAndSet, Idea, backgroundCanvas, byTags, collisionRect, fromCharCode, game, gameHeight, gameWidth, game_screen, instanceArray, newAudio, playingSounds, room, useDom, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  if (typeof jQuery === "undefined" || jQuery === null) {
    throw new Error("jQuery is not defined");
  }

  $ = jQuery;

  Idea = function(arg, n, d, f) {
    var b, gameObjectArray, i, inst, insts, isListOfNumbers, nType, newInsts, obj, theType, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _ref, _ref1, _ref2, _results, _results1;
    theType = $.type(arg);
    nType = $.type(n);
    isListOfNumbers = /^(?:\d,?)+$/;
    gameObjectArray = function(original) {
      var arr;
      arr = original.slice(0);
      arr.on = function() {
        var obj, _i, _len;
        for (_i = 0, _len = this.length; _i < _len; _i++) {
          obj = this[_i];
          obj.on.apply(obj, arguments);
        }
        return this;
      };
      arr.collides = function() {
        var obj, _i, _len;
        for (_i = 0, _len = this.length; _i < _len; _i++) {
          obj = this[_i];
          obj.collides.apply(obj, arguments);
        }
        return this;
      };
      return arr;
    };
    if (__indexOf.call(Idea.allObjects, arg) >= 0 && __indexOf.call(Idea.allRooms, n) >= 0) {
      return n.allInstances[arg.objectId];
    } else if (__indexOf.call(Idea.allObjects, arg) >= 0 && (nType === "undefined" || n === "current")) {
      return Idea(arg, Idea.getRoom());
    } else if (theType === "undefined" || theType === "null") {
      return Idea.allObjects;
    } else if (theType === "number" && nType === "undefined") {
      return Idea.allObjects[arg];
    } else if (theType === "number" && n === "current") {
      return Idea(Idea(arg));
    } else if (theType === "number" && __indexOf.call(Idea.allRooms, n) >= 0) {
      return Idea(Idea(arg), n);
    } else if (theType === "string") {
      switch (arg) {
        case "iterate":
          return Idea.apply(["iterate forward"].concat([].slice.call(arguments, 1)));
        case "iterate forward":
          insts = Idea(n, d);
          _results = [];
          for (_i = 0, _len = insts.length; _i < _len; _i++) {
            inst = insts[_i];
            _results.push(f.call(inst));
          }
          return _results;
          break;
        case "iterate backward":
          insts = Idea(n, d);
          _results1 = [];
          for (i = _j = _ref = insts.length; _ref <= 0 ? _j < 0 : _j > 0; i = _ref <= 0 ? ++_j : --_j) {
            inst = insts[i - 1];
            _results1.push(f.call(inst));
          }
          return _results1;
          break;
        default:
          if (isListOfNumbers.test(arg)) {
            if (nType === "undefined") {
              b = (function() {
                var _k, _len1, _ref1, _results2;
                _ref1 = arg.split(",");
                _results2 = [];
                for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
                  i = _ref1[_k];
                  _results2.push(Idea(parseInt(i, 10)));
                }
                return _results2;
              })();
              return gameObjectArray(b);
            } else if (n === "current" || __indexOf.call(Idea.allRooms, n) >= 0) {
              b = (function() {
                var _k, _len1, _ref1, _results2;
                _ref1 = arg.split(",");
                _results2 = [];
                for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
                  i = _ref1[_k];
                  _results2.push(parseInt(i, 10));
                }
                return _results2;
              })();
              newInsts = instanceArray();
              for (_k = 0, _len1 = b.length; _k < _len1; _k++) {
                obj = b[_k];
                _ref1 = Idea(obj, n);
                for (_l = 0, _len2 = _ref1.length; _l < _len2; _l++) {
                  inst = _ref1[_l];
                  newInsts.push(inst);
                }
              }
              return newInsts;
            }
          } else if (theType === "string" && nType === "undefined") {
            b = byTags[arg];
            if (b == null) {
              if (!Idea.settings.suppressTagWarnings) {
                console.error("Bad tag name");
              }
              return;
            }
            return gameObjectArray(b);
          } else if (theType === "string" && (n === "current" || __indexOf.call(Idea.allRooms, n) >= 0)) {
            b = byTags[arg];
            if (b == null) {
              if (!Idea.settings.suppressTagWarnings) {
                console.error("Bad tag name");
              }
            }
            newInsts = instanceArray();
            for (_m = 0, _len3 = b.length; _m < _len3; _m++) {
              obj = b[_m];
              _ref2 = Idea(obj, n);
              for (_n = 0, _len4 = _ref2.length; _n < _len4; _n++) {
                inst = _ref2[_n];
                newInsts.push(inst);
              }
            }
            return newInsts;
          } else {
            throw new Error("Unrecognizable arguments");
          }
      }
    }
  };

  fromCharCode = function(chr) {
    var from32to40, letters, ret;
    letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    from32to40 = "space,page up,page down,end,home,left,up,right,down".split(",");
    ret = (function() {
      switch (chr) {
        case 8:
          return "backspace";
        case 9:
          return "tab";
        case 13:
          return "enter";
        case 16:
          return "shift";
        case 17:
          return "ctrl";
        case 18:
          return "alt";
        case 20:
          return "caps lock";
        case 27:
          return "esc";
        case 45:
          return "insert";
        case 46:
          return "delete";
        case 188:
          return ",";
        case 190:
          return ".";
        case 191:
          return "/";
        case 192:
          return "`";
        case 219:
          return "[";
        case 220:
          return "\\";
        case 222:
          return "'";
        default:
          return null;
      }
    })();
    if (!ret) {
      if ((32 <= chr && chr <= 40)) {
        ret = from32to40[chr - 32];
      }
      if ((48 <= chr && chr <= 57)) {
        ret = (chr - 48) + "";
      }
      if ((65 <= chr && chr <= 90)) {
        ret = letters[chr - 65];
      }
      if ((112 <= chr && chr <= 123)) {
        ret = "f" + (chr - 111);
      }
    }
    return ret;
  };

  room = null;

  useDom = false;

  game_screen = null;

  gameWidth = null;

  gameHeight = null;

  game = null;

  backgroundCanvas = null;

  byTags = {};

  GetAndSet = function() {
    var fn, i, len, prop, props, retVal, _i, _j, _len;
    len = arguments[0], props = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    retVal = [];
    for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
      retVal.push({});
    }
    for (_j = 0, _len = props.length; _j < _len; _j++) {
      prop = props[_j];
      if (prop.slice(0, 3) === "fn:") {
        fn = prop.slice(3);
        (function(fn) {
          return retVal[fn] = function() {
            var inst, _k, _len1, _results;
            _results = [];
            for (_k = 0, _len1 = this.length; _k < _len1; _k++) {
              inst = this[_k];
              _results.push(inst[fn].apply(inst, arguments));
            }
            return _results;
          };
        })(fn);
      } else {
        (function(prop) {
          return Object.defineProperty(retVal, prop, {
            set: function(val) {
              var _k, _len1;
              for (_k = 0, _len1 = this.length; _k < _len1; _k++) {
                i = this[_k];
                i[prop] = val;
              }
            },
            get: function(val) {
              var _ref;
              return (_ref = this[0]) != null ? _ref[prop] : void 0;
            }
          });
        })(prop);
      }
    }
    retVal.attr = function(prop, val) {
      var _k, _len1;
      for (_k = 0, _len1 = this.length; _k < _len1; _k++) {
        i = this[_k];
        i.attr.apply(i, arguments);
      }
      return this;
    };
    return retVal;
  };

  instanceArray = function() {
    return GetAndSet(0, 'x', 'y', 'vx', 'vy', 'useBackCan', 'deactivateOut', 'sprite', 'create', 'begin step', 'draw', 'step', 'end step', 'events', 'collision', 'visible', 'fn:destroy', 'fn:moveUp', 'fn:moveDown', 'fn:moveRight', 'fn:moveLeft', 'fn:fourDirections');
  };

  Idea.init = function(xGameWidth, xGameHeight, xUseDom, root) {
    var fps, fpsFilter, gameInterval, lastUpdate, r, xBackgroundCanvas, xGame_screen, _i, _len, _ref, _ref1, _ref2;
    if (xUseDom == null) {
      xUseDom = false;
    }
    if (root == null) {
      root = "body";
    }
    if (!xUseDom) {
      xGame_screen = $("<canvas width=" + xGameWidth + " height=" + xGameHeight + ">").css({
        "position": "absolute",
        "z-index": 0
      });
      xBackgroundCanvas = $("<canvas width=" + xGameWidth + " height=" + xGameHeight + ">").css({
        "position": "absolute",
        "z-index": -1
      });
      $(root).append(xBackgroundCanvas).append(xGame_screen);
      useDom = false;
      _ref = [xGame_screen[0], xBackgroundCanvas[0]], game_screen = _ref[0], backgroundCanvas = _ref[1];
    } else {
      $(root).css({
        position: "absolute",
        width: xGameWidth,
        height: xGameHeight
      });
      game_screen = $(root)[0];
      useDom = true;
    }
    _ref1 = [xGameWidth, xGameHeight], gameWidth = _ref1[0], gameHeight = _ref1[1];
    (function() {
      var lastTime, vendor, vendors, _i, _len;
      lastTime = 0;
      vendors = ['ms', 'moz', 'webkit', 'o'];
      for (_i = 0, _len = vendors.length; _i < _len; _i++) {
        vendor = vendors[_i];
        if (window.requestAnimationFrame) {
          break;
        }
        window.requestAnimationFrame = window[vendor + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendor + 'CancelAnimationFrame'] || window[vendor + 'CancelRequestAnimationFrame'];
      }
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function(callback, element) {
          var currTime, id, timeToCall;
          currTime = new Date().getTime();
          timeToCall = Math.max(0, 16 - (currTime - lastTime));
          id = window.setTimeout((function() {
            return callback(currTime + timeToCall);
          }), timeToCall);
          lastTime = currTime + timeToCall;
          return id;
        };
        return window.cancelAnimationFrame = function(id) {
          return clearTimeout(id);
        };
      }
    })();
    gameInterval = 0;
    fps = 0;
    lastUpdate = Date.now();
    fpsFilter = 50;
    this.basicFunctionsStart();
    _ref2 = Idea.allRooms;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      r = _ref2[_i];
      r.renderBackPic();
    }
    game = {
      play: function() {
        var fun,
          _this = this;
        fun = function() {
          var now, thisFrameFPS;
          gameInterval = requestAnimationFrame(fun);
          if (Idea.assetsLoaded === Idea.assets.length) {
            if (!_this.loaded) {
              _this.loaded = true;
              _this.finishLoad();
            }
            if (room != null) {
              room.refresh();
            }
            Idea.basicFunctionsEnd();
            thisFrameFPS = 1000 / ((now = Date.now()) - lastUpdate);
            fps += (thisFrameFPS - fps) / fpsFilter;
            return lastUpdate = now;
          } else {
            return _this.load(Idea.assetsLoaded / Idea.assets.length);
          }
        };
        return gameInterval = requestAnimationFrame(fun);
      },
      fps: function() {
        if (fps !== fps) {
          return fps = 60;
        } else {
          return fps;
        }
      },
      pause: function() {
        return cancelAnimationFrame(gameInterval);
      },
      load: function(progress) {
        var ctx, x, y;
        ctx = Idea.getCanvasContext();
        ctx.save();
        ctx.fillStyle = Idea.settings.loadColor;
        ctx.strokeStyle = Idea.settings.loadColor;
        x = Idea.gameWidth() / 2 - 50;
        y = Idea.gameHeight() / 2 - 25;
        ctx.fillRect(x, y, progress * 100, 50);
        ctx.strokeRect(x, y, 100, 50);
        return ctx.restore();
      },
      finishLoad: function() {
        return room != null ? typeof room.refreshBackground === "function" ? room.refreshBackground() : void 0 : void 0;
      },
      loaded: false
    };
    return game;
  };

  Idea.game = function() {
    return game;
  };

  Idea.settings = {
    bufferDestroy: true,
    bufferRoomGoto: true,
    suppressAudioWarnings: false,
    suppressTagWarnings: false,
    suppressAlarmWarnings: false,
    loadColor: "red"
  };

  Idea.support = {
    audio: "Audio" in window,
    canvas: ((_ref = document.createElement("canvas")) != null ? _ref.tagName : void 0) != null ? true : false
  };

  Idea.getScreen = function() {
    return game_screen;
  };

  Idea.getCanvasContext = function() {
    return typeof game_screen.getContext === "function" ? game_screen.getContext("2d") : void 0;
  };

  Idea.getBackCanContext = function() {
    return typeof backgroundCanvas.getContext === "function" ? backgroundCanvas.getContext("2d") : void 0;
  };

  Idea.getBackgroundCanvas = function() {
    return backgroundCanvas;
  };

  Idea.gameWidth = function() {
    return gameWidth;
  };

  Idea.gameHeight = function() {
    return gameHeight;
  };

  Idea.defineSettings = function(newSettings) {
    return $.extend(this.settings, newSettings);
  };

  Idea.allObjects = [];

  Idea.gameObject = function(args, tags) {
    var gmInstance, newAngles;
    if (tags == null) {
      tags = [];
    }
    newAngles = function(x, y, degrees, centerX, centerY) {
      var theta, x2, y2;
      theta = degrees / 360 * (Math.PI * 2);
      x2 = centerX + (x - centerX) * Math.cos(Math.PI * 2 - theta) + (y - centerY) * Math.sin(Math.PI * 2 - theta);
      y2 = centerY - (x - centerX) * Math.sin(Math.PI * 2 - theta) + (y - centerY) * Math.cos(Math.PI * 2 - theta);
      return [x2, y2];
    };
    gmInstance = (function() {
      var i, _i, _len;

      function gmInstance(gx, gy) {
        var _ref1, _ref2, _ref3, _ref4;
        if ((_ref1 = this.sprite) != null ? _ref1.useDom : void 0) {
          this.statics = this.useBackCan = false;
        }
        if ((_ref2 = this.sprite) != null) {
          _ref2.createDiv();
        }
        if (this.width == null) {
          this.width = (_ref3 = this.sprite) != null ? _ref3.width : void 0;
        }
        if (this.height == null) {
          this.height = (_ref4 = this.sprite) != null ? _ref4.height : void 0;
        }
        if (this.statics) {
          this.deactivateOut = true;
          this.useBackCan = true;
        }
        room.allInstances[gmInstance.objectId].push(this);
        if (this.useBackCan) {
          room.staticInst.push(this);
        }
        this.constructor = gmInstance;
        this.prevX = this.x = gx;
        this.prevY = this.y = gy;
        this.vx = this.vy = 0;
        this.created = false;
        this.imgAngle = 0;
        this.imgScaleX = this.imgScaleY = 1;
        this.id = room.allInstances[gmInstance.objectId].length;
      }

      gmInstance.prototype.statics = false;

      gmInstance.prototype.sprite = null;

      gmInstance.prototype.visible = true;

      gmInstance.prototype.width = null;

      gmInstance.prototype.deactivateOut = false;

      gmInstance.prototype.useBackCan = false;

      gmInstance.prototype.deactivateOut = false;

      gmInstance.prototype.visible = true;

      gmInstance.prototype.attr = function(str, value) {
        var key;
        if ($.type(str) === "string") {
          this[str] = value;
        } else if ($.type(str) === "object") {
          for (key in str) {
            if (str.hasOwnProperty(key)) {
              this[key] = str[key];
            }
          }
        }
        return this;
      };

      gmInstance.prototype.nullified = false;

      gmInstance.prototype.destroy = function(buffer) {
        var ind, ind2, insts, obj, _ref1, _ref2;
        if (buffer == null) {
          buffer = Idea.settings.bufferDestroy;
        }
        if (buffer) {
          room.toDestroy.push(this);
          return;
        }
        obj = this.constructor;
        if ((_ref1 = this.sprite) != null ? _ref1.useDom : void 0) {
          if ((_ref2 = $(".divSprite" + this.sprite.id + ":eq(" + (this.id - 1) + ")")) != null) {
            _ref2.remove();
          }
        }
        insts = Idea(obj, room);
        ind = insts.indexOf(this);
        if (__indexOf.call(room.staticInst, this) >= 0) {
          ind2 = room.staticInst.indexOf(this);
          room.staticInst.splice(ind2, 1);
        }
        insts.splice(ind, 1);
      };

      gmInstance.prototype.mask = function() {
        var newangles, newangles2, newangles3, newangles4, objx, objy;
        if (this.imgAngle === 0) {
          return {
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.height
          };
        }
        newangles = newAngles(this.x, this.y, this.imgAngle, this.x + this.width / 2, this.y + this.height / 2);
        newangles2 = newAngles(this.x + this.width, this.y + this.height, this.imgAngle, this.x + this.width / 2, this.y + this.height / 2);
        newangles3 = newAngles(this.x, this.y + this.height, this.imgAngle, this.x + this.width / 2, this.y + this.height / 2);
        newangles4 = newAngles(this.x + this.height, this.y, this.imgAngle, this.x + this.width / 2, this.y + this.height / 2);
        objx = Math.min(newangles[0], newangles2[0], newangles3[0], newangles4[0]);
        objy = Math.min(newangles[1], newangles2[1], newangles3[1], newangles4[1]);
        return {
          x: objx,
          y: objy,
          width: (Math.max(newangles[0], newangles2[0], newangles3[0], newangles4[0])) - objx,
          height: (Math.max(newangles[1], newangles2[1], newangles3[1], newangles4[1])) - objy
        };
      };

      gmInstance.prototype.moveUp = function(speed, callback, key) {
        if (speed == null) {
          speed = 1;
        }
        if (key == null) {
          key = "up";
        }
        if ($.type(callback) === "string") {
          key = callback;
        }
        this["keydown-" + key] = function() {
          this.vy = -speed;
          return typeof callback === "function" ? callback("up") : void 0;
        };
        this["keyup-" + key] = function() {
          return this.vy = 0;
        };
        return this;
      };

      gmInstance.prototype.moveDown = function(speed, callback, key) {
        if (speed == null) {
          speed = 1;
        }
        if (key == null) {
          key = "down";
        }
        if ($.type(callback) === "string") {
          key = callback;
        }
        this["keydown-" + key] = function() {
          this.vy = speed;
          return typeof callback === "function" ? callback("down") : void 0;
        };
        this["keyup-" + key] = function() {
          return this.vy = 0;
        };
        return this;
      };

      gmInstance.prototype.moveLeft = function(speed, callback, key) {
        if (speed == null) {
          speed = 1;
        }
        if (key == null) {
          key = "left";
        }
        if ($.type(callback) === "string") {
          key = callback;
        }
        this["keydown-" + key] = function() {
          this.vx = -speed;
          return typeof callback === "function" ? callback("left") : void 0;
        };
        this["keyup-" + key] = function() {
          return this.vx = 0;
        };
        return this;
      };

      gmInstance.prototype.moveRight = function(speed, callback, key) {
        if (speed == null) {
          speed = 1;
        }
        if (key == null) {
          key = "right";
        }
        if ($.type(callback) === "string") {
          key = callback;
        }
        this["keydown-" + key] = function() {
          this.vx = speed;
          return typeof callback === "function" ? callback("right") : void 0;
        };
        this["keyup-" + key] = function() {
          return this.vx = 0;
        };
        return this;
      };

      gmInstance.prototype.fourDirections = function(speed, callback, keys) {
        if (keys == null) {
          keys = ["up", "down", "left", "right"];
        }
        if ($.type(callback) === "array") {
          keys = callback;
        }
        this.moveUp(speed, callback, keys[0]).moveDown(speed, callback, keys[1]).moveLeft(speed, callback, keys[2]).moveRight(speed, callback, keys[3]);
        return this;
      };

      gmInstance.prototype.stopMovement = function() {
        this.vx = this.vy = 0;
        this.x = this.prevX;
        return this.y = this.prevY;
      };

      gmInstance.prototype.glideTo = function(ox, oy, speed) {
        var difX, difY, n, x, y, _ref1, _ref2;
        if (speed == null) {
          speed = 1;
        }
        _ref1 = [this.x, this.y], x = _ref1[0], y = _ref1[1];
        difX = x - ox;
        difY = y - oy;
        n = Math.sqrt((difX * difX + difY * difY) / (speed * speed));
        return _ref2 = [difX / n, difY / n], this.vx = _ref2[0], this.vy = _ref2[1], _ref2;
      };

      gmInstance.prototype.draw = function(ctx) {
        var _ref1, _ref2;
        if ((_ref1 = this.sprite) != null) {
          _ref1.draw(ctx, this.x, this.y, this.id);
        }
        return (_ref2 = this.sprite) != null ? _ref2.refreshAnimation(room.allInstances[this.constructor.objectId][0] === this) : void 0;
      };

      gmInstance.prototype.collision = {};

      gmInstance.prototype.direction = function(vx, vy) {
        var degrees;
        if (vx == null) {
          vx = this.vx;
        }
        if (vy == null) {
          vy = this.vy;
        }
        degrees = Math.atan2(vy, vx) * 180 / Math.PI;
        return ((degrees + 360) % 360) % 360;
      };

      gmInstance.prototype.speed = function(vx, vy) {
        if (vx == null) {
          vx = this.vx;
        }
        if (vy == null) {
          vy = this.vy;
        }
        return Math.sqrt(vx * vx + vy * vy);
      };

      gmInstance.prototype.events = function() {
        var c, ctx, evalArray, i, ind, insideView, inst, insts, key, obj, _i, _j, _k, _l, _len, _len1, _len2, _len3, _name, _name1, _name2, _name3, _name4, _name5, _ref1, _ref2, _ref3, _ref4, _ref5,
          _this = this;
        evalArray = function() {
          var args, caller, fns, i, _i, _len, _results;
          fns = arguments[0], caller = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
          switch ($.type(fns)) {
            case "function":
              return fns.apply(caller, args);
            case "array":
              _results = [];
              for (_i = 0, _len = fns.length; _i < _len; _i++) {
                i = fns[_i];
                _results.push(i.apply(caller, args));
              }
              return _results;
              break;
            default:
              return false;
          }
        };
        if (!this.created) {
          this.created = true;
          evalArray(this.create, this);
        }
        evalArray(this["begin step"], this);
        if (!useDom) {
          ctx = game_screen.getContext('2d');
        }
        insideView = collisionRect(this.mask(), (function() {
          var v;
          v = room.view();
          return {
            x: v[0],
            y: v[1],
            width: gameWidth,
            height: gameHeight
          };
        })());
        this.visible = insideView;
        if (!insideView && this.deactivateOut) {
          room.deactivated.push(this);
          insts = Idea(gmInstance, room);
          ind = insts.indexOf(this);
          insts.splice(ind, 1);
          if (this.sprite.useDom) {
            $(".divSprite" + this.sprite.id + ":eq(" + (this.id - 1) + ")").css("display", "none");
          }
          return;
        }
        if (insideView && this.deactivateOut && useDom) {
          $(".divSprite" + this.sprite.id + ":eq(" + (this.id - 1) + ")").css("display", "block");
        }
        if ((this.draw != null) && !this.useBackCan) {
          if (useDom) {
            evalArray(this.draw, this, game_screen);
          } else {
            ctx.save();
            ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
            ctx.rotate(this.imgAngle * Math.PI / 180);
            ctx.scale(this.imgScaleX, this.imgScaleY);
            ctx.translate(-(this.x + this.width / 2), -(this.y + this.height / 2));
            evalArray(this.draw, this, ctx);
            ctx.restore();
          }
        }
        if (this.nullified) {
          return false;
        }
        evalArray(this.step, this);
        for (i in (_ref1 = this.collision) != null ? _ref1 : {}) {
          if (!this.collision.hasOwnProperty(i)) {
            continue;
          }
          obj = Idea.allObjects[parseInt(i, 10)];
          _ref2 = room.allInstances[obj.objectId];
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            inst = _ref2[_i];
            if (inst.nullified) {
              continue;
            }
            c = collisionRect(inst.mask(), this.mask());
            if (c) {
              evalArray(this.collision[i], this, inst, c);
            }
          }
        }
        (function() {
          var intr;
          intr = _this["intersect boundary"];
          if (_this.x + _this.width > room.w) {
            evalArray(intr, _this, "right");
          }
          if (_this.y + _this.height > room.h) {
            evalArray(intr, _this, "bottom");
          }
          if (_this.x < 0) {
            evalArray(intr, _this, "left");
          }
          if (_this.y < 0) {
            return evalArray(intr, _this, "top");
          }
        })();
        (function() {
          var outs;
          outs = _this["outside room"];
          if (_this.x > room.w) {
            evalArray(outs, _this, "right");
          }
          if (_this.x + _this.width < 0) {
            evalArray(outs, _this, "left");
          }
          if (_this.y > room.h) {
            evalArray(outs, _this, "bottom");
          }
          if (_this.y + _this.height < 0) {
            return evalArray(outs, _this, "top");
          }
        })();
        (function() {
          var intr, outs, theView;
          theView = {
            x: room.view()[0],
            y: room.view()[1],
            left: room.view()[0] + gameWidth,
            bottom: room.view()[1] + gameHeight
          };
          intr = _this["intersect view"];
          outs = _this["outside view"];
          if (_this.x + _this.width > theView.left) {
            evalArray(intr, _this, "right");
          }
          if (_this.y + _this.height > theView.bottom) {
            evalArray(intr, _this, "bottom");
          }
          if (_this.x < theView.x) {
            evalArray(intr, _this, "left");
          }
          if (_this.y < theView.y) {
            evalArray(intr, _this, "top");
          }
          if (_this.x > theView.w) {
            evalArray(outs, _this, "right");
          }
          if (_this.x + _this.width < theView.x) {
            evalArray(outs, _this, "left");
          }
          if (_this.y > theView.bottom) {
            evalArray(outs, _this, "bottom");
          }
          if (_this.y + _this.height < theView.y) {
            return evalArray(outs, _this, "top");
          }
        })();
        _ref3 = Idea.globalKeysdown;
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          key = _ref3[_j];
          if (typeof this[_name = "keydown-" + (fromCharCode(key))] === "function") {
            this[_name]();
          }
        }
        _ref4 = Idea.globalKeysup;
        for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
          key = _ref4[_k];
          if (typeof this[_name1 = "keyup-" + (fromCharCode(key))] === "function") {
            this[_name1]();
          }
        }
        _ref5 = Idea.globalKeyspressed;
        for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
          key = _ref5[_l];
          if (typeof this[_name2 = "keypressed-" + (fromCharCode(key))] === "function") {
            this[_name2]();
          }
        }
        if (Idea.globalMousedown) {
          if (typeof this[_name3 = "mousedown-" + Idea.globalMousedown] === "function") {
            this[_name3]();
          }
        }
        if (Idea.globalMousepressed) {
          if (typeof this[_name4 = "mousepressed-" + Idea.globalMousepressed] === "function") {
            this[_name4]();
          }
        }
        if (Idea.globalMouseup) {
          if (typeof this[_name5 = "mouseup-" + Idea.globalMouseup] === "function") {
            this[_name5]();
          }
        }
        this.prevX = this.x;
        this.prevY = this.y;
        this.x += this.vx;
        this.y += this.vy;
        evalArray(this["end step"], this);
      };

      Idea.allObjects.push(gmInstance);

      gmInstance.objectId = Idea.allObjects.length - 1;

      Idea.allRooms.forEach(function(v, i, l) {
        return l[i].allInstances.push(instanceArray());
      });

      for (_i = 0, _len = tags.length; _i < _len; _i++) {
        i = tags[_i];
        if (byTags[i] != null) {
          byTags[i].push(gmInstance);
        } else {
          byTags[i] = [gmInstance];
        }
      }

      gmInstance.on = function(_events, fn, overwrite) {
        var event, events, inst, isCollisionEvent, pr, _j, _k, _len1, _len2, _ref1, _with;
        if (overwrite == null) {
          overwrite = false;
        }
        events = _events.split(", ");
        isCollisionEvent = "collision-with-";
        for (_j = 0, _len1 = events.length; _j < _len1; _j++) {
          event = events[_j];
          if (event.indexOf(isCollisionEvent) === 0) {
            _with = event.slice(isCollisionEvent.length);
            this.collides(_with, fn, overwrite);
            continue;
          }
          pr = this.prototype[event];
          if ((pr == null) || overwrite) {
            this.prototype[event] = fn;
          } else if ($.type(pr) === "function") {
            this.prototype[event] = [pr, fn];
          } else if ($.type(pr) === "array") {
            pr.push(fn);
          }
          if (room != null) {
            _ref1 = Idea(this, "current");
            for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
              inst = _ref1[_k];
              if (inst.hasOwnProperty(event)) {
                delete inst[event];
              }
            }
          }
        }
        return this;
      };

      gmInstance.collides = function(_with, fn, overwrite) {
        var inst, oObj, obj, objs, pr, w, _j, _k, _l, _len1, _len2, _len3, _ref1;
        if (overwrite == null) {
          overwrite = false;
        }
        if (this.collision == null) {
          this.collision = {};
        }
        if ($.type(_with) === "object") {
          _with = _width.objectId.toString();
        }
        w = _with.split(", ");
        for (_j = 0, _len1 = w.length; _j < _len1; _j++) {
          obj = w[_j];
          if ((parseInt(obj, 10)) === (parseInt(obj, 10))) {
            pr = this.prototype.collision[obj];
            if ((pr == null) || overwrite) {
              this.prototype.collision[obj] = fn;
            } else if ($.type(pr) === "function") {
              this.prototype.collision[obj] = [pr, fn];
            } else if ($.type(pr) === "array") {
              pr.push(fn);
            }
          } else {
            objs = Idea(obj);
            for (_k = 0, _len2 = objs.length; _k < _len2; _k++) {
              oObj = objs[_k];
              pr = this.prototype.collision[oObj.objectId];
              if ((pr == null) || overwrite) {
                this.prototype.collision[oObj.objectId] = fn;
              } else if ($.type(pr) === "function") {
                this.prototype.collision[oObj.objectId] = [pr, fn];
              } else if ($.type(pr) === "array") {
                pr.push(fn);
              }
            }
          }
          if (room != null) {
            _ref1 = Idea(this);
            for (_l = 0, _len3 = _ref1.length; _l < _len3; _l++) {
              inst = _ref1[_l];
              delete inst.collision;
            }
          }
        }
        return this;
      };

      $.extend(gmInstance.prototype, args);

      return gmInstance;

    })();
    return gmInstance;
  };

  Idea.getByTags = function() {
    return byTags;
  };

  Idea.assets = [];

  Idea.assetsLoaded = 0;

  playingSounds = [];

  newAudio = function() {
    return (new Audio()) || document.createElement("Audio");
  };

  Idea.Sound = (function() {
    Sound.prototype.trackID = 0;

    function Sound(src, numTracks, onload) {
      var cpt, ending, i, maybes, _i, _len, _ref1, _ref2,
        _this = this;
      if (numTracks == null) {
        numTracks = 3;
      }
      if (!Idea.support.audio) {
        return;
      }
      this.unusedTracks = [];
      this.tracks = [];
      this.loadedTracks = [];
      if ($.type(src) === "object") {
        _ref1 = [src.source, src.tracks, src.onload], src = _ref1[0], numTracks = _ref1[1], onload = _ref1[2];
      }
      if ($.type(numTracks) === "function") {
        _ref2 = [numTracks, 5], onload = _ref2[0], numTracks = _ref2[1];
      }
      this.loaded = false;
      this.sound = newAudio();
      if ($.type(src) === "array") {
        maybes = [];
        for (_i = 0, _len = src.length; _i < _len; _i++) {
          i = src[_i];
          ending = i.substr((i.lastIndexOf(".")) + 1);
          cpt = this.sound.canPlayType("audio/" + ending);
          if (cpt === "probably" && ending !== "wav") {
            src = i;
            break;
          } else if (cpt === "maybe" || ending === "wav") {
            maybes.push(i);
          }
        }
        if ($.type(src) === "array") {
          src = maybes[0];
          if (src.substr(src.lastIndexOf(".") + 1) === "wav" && (maybes[1] != null)) {
            src = maybes[1];
          }
          if (src == null) {
            if (!Idea.settings.suppressAudioWarnings) {
              console.warn("No audio file formats were found applicable");
            }
            src = src[0];
          }
        }
      }
      $(this.sound).on("canplaythrough", function() {
        var ii, _fn, _j;
        if (_this.loaded) {
          return;
        }
        Idea.assetsLoaded++;
        _this.loaded = true;
        if (onload != null) {
          onload.call(_this);
        }
        if (_this.sound.duration > 5 && _this.sound.src.substr(_this.sound.src.lastIndexOf(".") + 1) === "wav") {
          _this.tracks = [_this.sound];
          _this.unusedTracks = [0];
          if (!Idea.settings.suppressAudioWarnings) {
            console.warn("Wav files are too big to load many. (Only one track will be loaded.)                Convert to ogg or mp3");
          }
        } else {
          _fn = function(ii) {
            $(_this.tracks[ii]).on("canplaythrough", function() {
              if (!_this.loadedTracks[ii]) {
                _this.loadedTracks[ii] = true;
                Idea.assetsLoaded++;
              }
            });
          };
          for (ii = _j = 0; _j < numTracks; ii = _j += 1) {
            _this.unusedTracks.push(ii);
            _this.tracks[ii] = newAudio();
            Idea.assets.push(_this.tracks[ii]);
            _fn(ii);
            _this.loadedTracks[ii] = false;
            _this.tracks[ii].src = src;
            _this.tracks[ii].preload = true;
          }
        }
      });
      this.sound.src = src;
      this.sound.preload = true;
      this.sound.load();
      Idea.assets.push(this.sound);
    }

    Sound.prototype.play = function(trackId) {
      var spliced,
        _this = this;
      if (trackId == null) {
        trackId = this.trackID;
      }
      if (this.tracks[trackId] == null) {
        if (!Idea.settings.suppressAudioWarnings) {
          console.error("Not enough tracks");
        }
        return;
      }
      this.tracks[trackId].play();
      $(this.tracks[trackId]).on("ended pause", function() {
        if (__indexOf.call(_this.unusedTracks, spliced) < 0) {
          _this.unusedTracks.push(spliced);
        }
        $(_this).off("ended pause");
        return _this.trackID = _this.unusedTracks[0];
      });
      spliced = this.unusedTracks.splice(this.unusedTracks.indexOf(trackId), 1)[0];
      this.trackID = this.unusedTracks[0];
      return trackId;
    };

    Sound.prototype.stop = function(trackId) {
      var track, _i, _len, _ref1;
      if (trackId == null) {
        _ref1 = this.tracks;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          track = _ref1[_i];
          track.pause();
        }
      } else {
        this.tracks[trackId].pause();
      }
      this.trackID = this.unusedTracks[0];
      return this.unusedTracks;
    };

    Sound.prototype.loop = function(trackId) {
      var spliced, trackID,
        _this = this;
      if (trackId == null) {
        trackId = trackID;
      }
      if (this.tracks[trackId] == null) {
        if (!Idea.settings.suppressAudioWarnings) {
          console.error("Not enough tracks");
        }
        return;
      }
      tracks[trackId].loop = true;
      tracks[trackId].play();
      $(tracks[trackID]).on("pause", function() {
        unusedTracks.push(spliced);
        return $(_this).off("ended pause");
      });
      spliced = unusedTracks.splice(unusedTracks.indexOf(trackId), 1)[0];
      trackID = unusedTracks[0];
      return trackId;
    };

    return Sound;

  })();

  Idea.playingSounds = function() {
    return playingSounds;
  };

  Idea.alarms = [];

  Idea.Alarm = (function() {
    function Alarm(frames, onFinish) {
      Idea.alarms.push(this);
      this.onEnd = onFinish != null ? [onFinish] : [];
      this.value = frames;
      this.startValue = frames;
    }

    Alarm.prototype.end = function(fn) {
      this.onEnd.push(fn);
      return this;
    };

    Alarm.prototype.startOver = function(frames) {
      if (frames == null) {
        frames = this.startValue;
      }
      this.value = frames;
      return this;
    };

    Alarm.prototype.trigger = function() {
      var fn, _i, _len, _ref1;
      _ref1 = this.onEnd;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        fn = _ref1[_i];
        fn.call(this);
      }
      return this;
    };

    return Alarm;

  })();

  Idea.removeAlarm = function(alarm) {
    var allAlarms;
    allAlarms = Idea.alarms;
    if ($.type(alarm) === "number") {
      return allAlarms.splice(alarm, 1);
    } else {
      if (__indexOf.call(allAlarms, alarm) < 0) {
        if (!Idea.settings.suppressAlarmWarnings) {
          console.error("Alarm not found!");
        }
        return;
      }
      return allAlarms.splice(allAlarms.indexOf(alarm), 1);
    }
  };

  Idea.removeAllAlarms = function() {
    var _results;
    _results = [];
    while (this.alarms[0]) {
      _results.push(this.removeAlarm(0));
    }
    return _results;
  };

  Idea.animation = function(divider, x, y, width, height) {
    var w, _i, _ref1, _results;
    if ($.type(divider) === "object") {
      _ref1 = divider, divider = _ref1.divider, x = _ref1.x, y = _ref1.y, width = _ref1.width, height = _ref1.height;
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
    }
    if (!((width != null) && (height != null))) {
      width = x;
      height = y;
      x = y = 0;
    }
    _results = [];
    for (w = _i = 0; divider > 0 ? _i < width : _i > width; w = _i += divider) {
      _results.push([x + w, y, divider, height]);
    }
    return _results;
  };

  Idea.Sprite = (function() {
    var createRepeating, ids, loadFunction, loadSrc, setSize;

    ids = 0;

    setSize = function(elem, width, height) {
      if (elem.tagName.toLowerCase() === "canvas") {
        elem.width = width;
        return elem.height = height;
      } else {
        return $(elem).css({
          width: width,
          height: height,
          position: "absolute"
        });
      }
    };

    createRepeating = function(args) {
      var context, newCanvas, pattern;
      newCanvas = document.createElement("canvas");
      newCanvas.width = args.screen.width;
      newCanvas.height = args.screen.height;
      context = newCanvas.getContext("2d");
      pattern = context.createPattern(args.screen, args.repeating === true ? "repeat" : args.repeating);
      context.rect(0, 0, newCanvas.width, newCanvas.height);
      context.fillStyle = pattern;
      context.fill();
      return newCanvas;
    };

    loadFunction = function(args) {
      var newCanvas;
      args.fn(args.screen);
      newCanvas = args.screen;
      if (!(args._useDom || args.repeating === false)) {
        newCanvas = createRepeating(args);
      }
      return newCanvas;
    };

    loadSrc = function(args) {
      var context, img, newCanvas,
        _this = this;
      img = new Image();
      newCanvas = args.screen;
      if (!args._useDom) {
        context = newCanvas.getContext("2d");
      }
      img.onload = function() {
        var pattern, _ref1;
        if (!args.repeating) {
          if (_this.width == null) {
            _this.width = img.width;
          }
          if (_this.height == null) {
            _this.height = img.height;
          }
          newCanvas.width = _this.width;
          newCanvas.height = _this.height;
          if (args._useDom) {
            newCanvas.appendChild(img);
          } else {
            context.drawImage(img, 0, 0, _this.width, _this.height);
          }
        } else {
          if (args._useDom) {
            throw new Error("DOM elements cannot have patterns");
          }
          pattern = context.createPattern(img, args.repeating === true ? "repeat" : args.repeating);
          context.rect(0, 0, _this.width, _this.height);
          context.fillStyle = pattern;
          context.fill();
        }
        Idea.assetsLoaded += 1;
        return (_ref1 = args.onload) != null ? _ref1.apply(_this) : void 0;
      };
      img.src = args.source;
      Idea.assets.push(img);
      return img;
    };

    function Sprite(args) {
      var newSource, offsetX, offsetY, onload, passArgs, repeating, source, tiles, tilesize, _useDom,
        _this = this;
      this.id = ids;
      ids++;
      if ($.type(args) === "string") {
        args = {
          source: args
        };
      }
      source = args.source, this.width = args.width, this.height = args.height, repeating = args.repeating, onload = args.onload, this.speed = args.speed, _useDom = args._useDom, tilesize = args.tilesize, tiles = args.tiles;
      if (repeating == null) {
        repeating = false;
      }
      if (this.speed == null) {
        this.speed = 1;
      }
      if (_useDom == null) {
        _useDom = false;
      }
      if (tilesize == null) {
        tilesize = 1;
      }
      passArgs = {
        source: source,
        width: this.width,
        height: this.height,
        repeating: repeating,
        onload: onload,
        speed: this.speed,
        _useDom: _useDom,
        tilesize: tilesize,
        tiles: tiles
      };
      this.screen = document.createElement(_useDom ? "div" : "canvas");
      if ((this.width != null) && (this.height != null)) {
        setSize(this.screen, this.width, this.height);
      }
      if ($.type(source) === "function") {
        this.type = "function";
        this.screen = loadFunction.call(this, {
          fn: source,
          width: this.width,
          height: this.height,
          repeating: repeating,
          onload: onload,
          speed: this.speed,
          _useDom: _useDom,
          tilesize: tilesize,
          tiles: tiles,
          screen: this.screen
        });
      } else if (tiles != null) {
        if (_useDom) {
          throw new Error("Cannot use tiles with DOM elements");
        }
        if ($.type(tiles[0]) !== "array") {
          offsetX = tiles[0] * tilesize;
          offsetY = tiles[1] * tilesize;
          this.screen.width = this.width = tiles[2] * tilesize;
          this.screen.height = this.height = tiles[3] * tilesize;
          _this = this;
          newSource = new Idea.Sprite({
            source: source,
            onload: function() {
              return this.draw(_this.screen.getContext("2d"), -offsetX, -offsetY, 1);
            }
          });
          this.type = "tileset";
        } else {
          if (this.width == null) {
            this.width = tiles[0][2] * tilesize;
          }
          if (this.height == null) {
            this.height = tiles[0][3] * tilesize;
          }
          this.imgs = tiles.map(function(tile) {
            return new Idea.Sprite({
              source: source,
              width: _this.width,
              height: _this.height,
              repeating: repeating,
              onload: onload,
              speed: _this.speed,
              _useDom: _useDom,
              tilesize: tilesize,
              tiles: tile
            });
          });
          this.imgInd = 0;
          this.type = "animation";
        }
      } else if ($.type(source) === "array") {
        this.type = "animation";
        if (_useDom) {
          throw new Error("Cannot create animation with DOM elements");
        }
        this.imgs = source.map(function(src) {
          return new Idea.Sprite({
            source: src,
            width: _this.width,
            height: _this.height,
            repeating: repeating,
            onload: onload,
            speed: _this.speed,
            _useDom: _useDom,
            tilesize: tilesize,
            tiles: tiles
          });
        });
        this.imgInd = 0;
      } else if ($.type(source) === "string") {
        this.type = "src";
        loadSrc.call(this, {
          source: source,
          width: this.width,
          height: this.height,
          repeating: repeating,
          onload: onload,
          speed: this.speed,
          _useDom: _useDom,
          tilesize: tilesize,
          tiles: tiles,
          screen: this.screen
        });
      }
      this.useDom = _useDom;
    }

    Sprite.prototype.draw = function(id, x, y, divId) {
      var theDiv, _ref1;
      if (!this.useDom) {
        switch (this.type) {
          case "src":
          case "function":
          case "tileset":
            return id.drawImage(this.screen, x, y);
          case "animation":
            return (_ref1 = this.imgs[Math.floor(this.imgInd)]).draw.apply(_ref1, arguments);
        }
      } else {
        theDiv = $(".divSprite" + this.id + ":eq(" + (divId - 1) + ")");
        return theDiv.css({
          left: "" + (x - room.view()[0]) + "px",
          top: "" + (y - room.view()[1]) + "px"
        });
      }
    };

    Sprite.prototype.refreshAnimation = function(isFirst) {
      if (this.type === "animation" && isFirst) {
        return this.imgInd = (this.imgInd + this.speed) % this.imgs.length;
      }
    };

    Sprite.prototype.createDiv = function() {
      var root, thisDiv;
      if (!this.useDom) {
        return;
      }
      thisDiv = $(this.screen).clone(true);
      thisDiv.attr("class", "divSprite" + this.id);
      root = useDom ? game_screen : "body";
      $(root).append(thisDiv);
      $(thisDiv).css({
        position: "absolute"
      });
    };

    return Sprite;

  })();

  collisionRect = function(a, b) {
    var bottom, left, min, right, top;
    if (!(a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y)) {
      return false;
    }
    top = b.y + b.height - a.y;
    bottom = a.y + a.height - b.y;
    right = a.x + a.width - b.x;
    left = b.x + b.width - a.x;
    min = Math.min(top, bottom, left, right);
    switch (min) {
      case top:
        return "top";
      case bottom:
        return "bottom";
      case right:
        return "right";
      case left:
        return "left";
      default:
        return "top";
    }
  };

  Idea.basicFunctionsStart = function() {
    var mDown;
    Idea.basicFunctionsEnd() != null;
    Idea.globalMouseX = Idea.globalMouseY = 0;
    Idea.globalKeysdown = [];
    Idea.globalMousedown = false;
    mDown = [];
    $(game_screen).contextmenu(function() {
      return false;
    }).mousemove(function(e) {
      Idea.globalMouseX = e.offsetX || e.pageX - $(this).offset().left;
      Idea.globalMouseY = e.offsetY || e.pageY - $(this).offset().top;
      return false;
    }).mousedown(function(e) {
      Idea.globalMousepressed = Idea.globalMousedown = e.which === 3 ? "right" : "left";
      return false;
    }).mouseup(function(e) {
      Idea.globalMousedown = false;
      Idea.globalMouseup = e.which === 3 ? "right" : "left";
      return false;
    }).dblclick(function(e) {
      return false;
    });
    $(document).keydown(function(e) {
      var d, p, w;
      d = Idea.globalKeysdown;
      p = Idea.globalKeyspressed;
      w = e.which;
      if (__indexOf.call(d, w) < 0) {
        d.push(w);
      }
      if (!(__indexOf.call(p, w) >= 0 || __indexOf.call(mDown, w) >= 0)) {
        p.push(w);
        mDown.push(w);
      }
      return false;
    }).keyup(function(e) {
      var d, u, w;
      d = Idea.globalKeysdown;
      u = Idea.globalKeysup;
      w = e.which;
      mDown.splice(mDown.indexOf(w), 1);
      if (__indexOf.call(u, w) < 0) {
        u.push(w);
      }
      d.splice(d.indexOf(w), 1);
      return false;
    });
  };

  Idea.basicFunctionsEnd = function() {
    Idea.globalKeysup = [];
    Idea.globalKeyspressed = [];
    Idea.globalMousepressed = Idea.globalMouseup = false;
  };

  Idea.math = {
    distance: function(x1, y1, x2, y2) {
      var _ref1, _ref2, _ref3;
      if ($.type(x1) === "object" && $.type(y1) === "object") {
        _ref1 = [x1.x, x1.y, y1.x, y1.y], x1 = _ref1[0], y1 = _ref1[1], x2 = _ref1[2], y2 = _ref1[3];
      } else if ($.type(x1) === "object" && $.type(y1) === "number" && $.type(x2) === "number") {
        _ref2 = [x1.x, x1.y, y1, x2], x1 = _ref2[0], y1 = _ref2[1], x2 = _ref2[2], y2 = _ref2[3];
      } else if ($.type(x1) === "number" && $.type(y1) === "number" && $.type(x2) === "object") {
        _ref3 = [x1, y1, x2.x, x2.y], x1 = _ref3[0], y1 = _ref3[1], x2 = _ref3[2], y2 = _ref3[3];
      }
      return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    },
    intersect: function(x1, y1, w1, h1, x2, y2, w2, h2) {
      var obj1, obj2, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      if ($.type(x1) === "object" && $.type(y1) === "object") {
        _ref1 = [x1, y1], obj1 = _ref1[0], obj2 = _ref1[1];
      }
      if ($.type(x1) === "object" && ((($.type(y1) === (_ref4 = $.type(w1)) && _ref4 === (_ref3 = $.type(h1))) && _ref3 === (_ref2 = $.type(x2))) && _ref2 === "number")) {
        obj1 = x1;
        obj2 = {
          x: y1,
          y: w1,
          width: h1,
          height: x2
        };
      }
      if (((($.type(x1) === (_ref7 = $.type(y1)) && _ref7 === (_ref6 = $.type(w1))) && _ref6 === (_ref5 = $.type(h1))) && _ref5 === "number") && $.type(x2) === "object") {
        obj1 = {
          x: x1,
          y: y1,
          width: w1,
          height: h1
        };
        obj2 = x2;
      }
      if ($.type(x1) === "number" && $.type(h2) === "number") {
        obj1 = {
          x: x1,
          y: y1,
          width: w1,
          height: h1
        };
        obj2 = {
          x: x2,
          y: y2,
          width: w2,
          height: h2
        };
      }
      return collisionRect(obj1, obj2);
    }
  };

  Idea.allRooms = [];

  Idea.Room = (function() {
    function Room(args) {
      var backPic, repeating, _ref1, _ref2, _ref3, _ref4, _ref5;
      if (args == null) {
        args = {};
      }
      _ref5 = [args.persistent, args.background, args.backPic, (_ref1 = args.width) != null ? _ref1 : gameWidth != null ? gameWidth : 0, (_ref2 = args.height) != null ? _ref2 : gameHeight != null ? gameHeight : 0, (_ref3 = args.repeating) != null ? _ref3 : true, (_ref4 = args.useBackCanvas) != null ? _ref4 : true], this.persistent = _ref5[0], this.background = _ref5[1], backPic = _ref5[2], this.w = _ref5[3], this.h = _ref5[4], repeating = _ref5[5], this.useBackCanvas = _ref5[6];
      this.toDestroy = [];
      this.following = {};
      this.roomToGoTo = false;
      this.allInstances = [];
      this.staticInst = [];
      this.deactivated = [];
      Idea.allRooms.push(this);
      this.id = Idea.allRooms.length - 1;
      this.dynamic = [];
      this.trx = 0;
      this["try"] = 0;
      this.renderBackPic = function() {
        var largePic, that;
        this.largeBackPics = this.w > gameWidth * 9 && this.h > gameHeight * 9 && (backPic != null);
        if (this.largeBackPics && (backPic != null) && !useDom) {
          largePic = new Image();
          this.smallCan = [];
          that = this;
          largePic.onload = function() {
            var c, ch, column, ctx, cw, n, row, _i, _j, _ref6, _ref7;
            for (row = _i = 0, _ref6 = largePic.width; gameWidth > 0 ? _i < _ref6 : _i > _ref6; row = _i += gameWidth) {
              n = that.smallCan.length;
              that.smallCan.push([]);
              for (column = _j = 0, _ref7 = largePic.height; gameHeight > 0 ? _j < _ref7 : _j > _ref7; column = _j += gameHeight) {
                c = document.createElement('canvas');
                c.width = gameWidth;
                c.height = gameHeight;
                ctx = c.getContext('2d');
                cw = row + gameWidth > this.width ? this.width - row : gameWidth;
                ch = column + gameHeight > this.height ? this.height - column : gameHeight;
                ctx.drawImage(this, row, column, cw, ch, 0, 0, cw, ch);
                that.smallCan[n].push(c);
              }
            }
          };
          if (repeating) {
            return new Idea.Sprite(backPic, this.w, this.h, repeating, function() {
              return largePic.src = this.c.toDataURL();
            });
          }
        } else if (backPic != null) {
          return this.backPic = new Idea.Sprite({
            source: backPic,
            width: this.w,
            height: this.h,
            repeating: repeating
          });
        }
      };
    }

    Room.prototype.refreshBackground = function() {
      var ceiledx, ceiledy, ctx, flooredx, flooredy, ind, insideView, inst, insts, newFunct, obj, roomBar, useBackCanvas, v, _i, _j, _len, _len1, _ref1, _ref2;
      if (this.useBackCanvas) {
        useBackCanvas = backgroundCanvas;
        ctx = useBackCanvas.getContext("2d");
        if (this.background != null) {
          ctx.fillStyle = this.background;
          ctx.fillRect(0, 0, useBackCanvas.width, useBackCanvas.height);
        } else if (this.backPic != null) {
          if (!this.largeBackPics) {
            ctx.drawImage(this.backPic.screen, Math.min(this.trx, this.w - gameWidth), Math.min(this["try"], this.h - gameHeight), useBackCanvas.width, useBackCanvas.height, 0, 0, useBackCanvas.width, useBackCanvas.height);
          } else {
            v = room.view();
            if (v[0] % gameWidth === 0 && v[1] % gameHeight === 0) {
              ctx.drawImage(this.smallCan[v[0] / gameWidth][v[1] / gameHeight], v[0], v[1]);
            } else {
              flooredx = Math.floor(v[0] / gameWidth);
              ceiledx = Math.ceil(v[0] / gameWidth);
              flooredy = Math.floor(v[1] / gameHeight);
              ceiledy = Math.ceil(v[1] / gameHeight);
              ctx.drawImage(this.smallCan[flooredx][flooredy], flooredx * gameWidth - v[0], flooredy * gameHeight - v[1]);
              ctx.drawImage(this.smallCan[flooredx][ceiledy], flooredx * gameWidth - v[0], ceiledy * gameHeight - v[1]);
              ctx.drawImage(this.smallCan[ceiledx][flooredy], ceiledx * gameWidth - v[0], flooredy * gameHeight - v[1]);
              ctx.drawImage(this.smallCan[ceiledx][ceiledy], ceiledx * gameWidth - v[0], ceiledy * gameHeight - v[1]);
            }
          }
        }
        newFunct = function() {
          var evalArray;
          evalArray = function() {
            var args, caller, fns, i, _i, _len, _results;
            fns = arguments[0], caller = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
            switch ($.type(fns)) {
              case "function":
                return fns.apply(caller, args);
              case "array":
                _results = [];
                for (_i = 0, _len = fns.length; _i < _len; _i++) {
                  i = fns[_i];
                  _results.push(i.apply(caller, args));
                }
                return _results;
                break;
              default:
                return false;
            }
          };
          if ((this.draw != null) && this.useBackCan) {
            ctx.save();
            ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
            ctx.rotate(this.imgAngle * Math.PI / 180);
            ctx.translate(-(this.x + this.width / 2), -(this.y + this.height / 2));
            ctx.translate(-room.trx, -room["try"]);
            evalArray(this.draw, this, ctx);
            return ctx.restore();
          }
        };
        _ref1 = this.staticInst;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          inst = _ref1[_i];
          newFunct.call(inst);
        }
        roomBar = (function() {
          v = room.view();
          return {
            x: v[0],
            y: v[1],
            width: gameWidth,
            height: gameHeight
          };
        })();
        _ref2 = this.deactivated;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          inst = _ref2[_j];
          if (!inst) {
            continue;
          }
          insideView = collisionRect(inst.mask(), roomBar);
          if (insideView) {
            obj = inst.constructor;
            ind = this.deactivated.indexOf(inst);
            this.deactivated.splice(ind, 1);
            if (inst.sprite.useDom) {
              $(".divSprite" + inst.sprite.id + ":eq(" + (inst.id - 1) + ")").css("display", "block");
            }
            insts = Idea(obj, this);
            insts.push(inst);
          }
        }
      }
    };

    Room.prototype.refresh = function(ctx) {
      var alarm, f, i, inst, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref1, _ref2, _ref3, _ref4;
      if (ctx == null) {
        ctx = useDom ? game_screen : game_screen.getContext('2d');
      }
      if (((this.background == null) || this.useBackCanvas) && !useDom) {
        ctx.clearRect(0, 0, room.w, room.h);
      } else if (((this.background != null) && !this.useBackCanvas) && !useDom) {
        ctx.fillStyle = this.background;
        ctx.fillRect(0, 0, room.w, room.h);
      } else if (this.background && useDom) {
        $(game_screen).css("background-color", this.background);
      }
      if (!(this.useBackCanvas || useDom)) {
        ctx.translate(-this.trx, -this["try"]);
        if ((_ref1 = this.backPic) != null) {
          if (typeof _ref1.draw === "function") {
            _ref1.draw(game_screen.getContext('2d'), 0, 0);
          }
        }
        ctx.restore();
      }
      if (!$.isEmptyObject(this.following)) {
        f = this.following;
        if (f.instance.y >= room.view()[1] + gameHeight - (f.borderY + f.instance.height) && room.view()[1] < room.h - gameHeight) {
          room.view(0, f.speedY);
        }
        if (f.instance.y <= room.view()[1] + f.borderY && room.view()[1] > 0) {
          room.view(0, -f.speedY);
        }
        if (f.instance.x >= room.view()[0] + gameWidth - (f.borderX + f.instance.width) && room.view()[0] < room.w - gameWidth) {
          room.view(f.speedX, 0);
        }
        if (f.instance.x <= room.view()[0] + f.borderX && room.view()[0] > 0) {
          room.view(-f.speedX, 0);
        }
      }
      _ref2 = Idea.alarms;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        alarm = _ref2[_i];
        if ((alarm != null ? alarm.value : void 0) > 0 && --alarm.value === 0) {
          alarm.value = -1;
          alarm.trigger();
        }
      }
      if (!useDom) {
        ctx.save();
        ctx.translate(-this.trx, -this["try"]);
      }
      _ref3 = room.allInstances;
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        i = _ref3[_j];
        for (_k = 0, _len2 = i.length; _k < _len2; _k++) {
          inst = i[_k];
          if (inst != null) {
            if (typeof inst.events === "function") {
              inst.events();
            }
          }
        }
      }
      if (!useDom) {
        ctx.restore();
      }
      _ref4 = this.toDestroy;
      for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
        inst = _ref4[_l];
        inst.destroy(false);
      }
      this.toDestroy = [];
      if (this.roomToGoTo) {
        Idea.roomGoto(this.roomToGoTo, false);
        this.roomToGoTo = false;
      }
    };

    Room.prototype.view = function(mx, my, relative) {
      var viewX, viewY, _ref1;
      if (mx == null) {
        mx = 0;
      }
      if (my == null) {
        my = 0;
      }
      if (relative == null) {
        relative = true;
      }
      _ref1 = [this.trx, this["try"]], viewX = _ref1[0], viewY = _ref1[1];
      if (relative) {
        this.trx += mx;
        this["try"] += my;
      } else {
        this.trx = mx;
        this["try"] = my;
      }
      if (!((relative && mx === 0 && my === 0) || (!relative && mx === viewX && my === viewY))) {
        if (typeof this.refreshBackground === "function") {
          this.refreshBackground();
        }
      }
      return [this.trx, this["try"]];
    };

    Room.prototype.follow = function(instance, borderX, borderY, speedX, speedY) {
      this.following.instance = instance;
      this.following.borderX = borderX;
      this.following.borderY = borderY;
      this.following.speedX = speedX;
      this.following.speedY = speedY;
    };

    return Room;

  })();

  Idea.roomGoto = function(newRoom, toBuffer, callback) {
    var i, inst, prevRoom, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref1, _ref2, _ref3;
    if (toBuffer == null) {
      toBuffer = Idea.settings.bufferRoomGoto;
    }
    if (toBuffer && (room != null)) {
      room.roomToGoTo = newRoom;
      switch (newRoom) {
        case "next":
          return Idea.allRooms[room.id + 1];
        case "previous":
          return Idea.allRooms[room.id - 1];
        default:
          return newRoom;
      }
    }
    prevRoom = room;
    if (prevRoom != null) {
      _ref1 = prevRoom.allInstances;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        i = _ref1[_i];
        for (_j = 0, _len1 = i.length; _j < _len1; _j++) {
          inst = i[_j];
          if (typeof inst.roomEnd === "function") {
            inst.roomEnd();
          }
        }
      }
      $("div[class^='divSprite']").remove();
      if (!prevRoom.persistent) {
        prevRoom.allInstances = instanceArray();
        _ref2 = Idea.allObjects;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          i = _ref2[_k];
          prevRoom.allInstances.push([]);
        }
      }
    }
    switch (newRoom) {
      case "next":
        room = Idea.allRooms[room.id + 1];
        break;
      case "previous":
        room = Idea.allRooms[room.id - 1];
        break;
      default:
        room = newRoom;
    }
    if (typeof room.create === "function") {
      room.create();
    }
    if (typeof room.refreshBackground === "function") {
      room.refreshBackground();
    }
    _ref3 = room.allInstances;
    for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
      i = _ref3[_l];
      for (_m = 0, _len4 = i.length; _m < _len4; _m++) {
        inst = i[_m];
        if (typeof inst.roomStart === "function") {
          inst.roomStart();
        }
      }
    }
    return room;
  };

  Idea.getRoom = function() {
    return room;
  };

  window["Idea"] = Idea;

}).call(this);
