// Generated by CoffeeScript 1.6.3
/*
Author: Praneeth Kolichala
Copyright (c) unofficially 2012-2013
Version: Beta 1.1.0
New in this version:
    - controls
    - Modules
    - All tags include "*"
    - Changed moveRight, moveLeft, etc. to be methods of a gameObject rather than an instance
    - @trigger method
    - Added @unbindCollision and @off
*/


(function() {
  "use strict";
  var $, Alarm, GameObjectArray, Idea, InstanceArray, Module, Room, Sound, Sprite, alarms, allObjects, allRooms, assets, backgroundCanvas, basicFunctionsEnd, basicFunctionsStart, byTags, collisionRect, controls, error, fromCharCode, game, gameHeight, gameWidth, game_screen, math, modules, newAudio, playingSounds, removeAlarm, room, roomGoto, settings, support, trigger, triggerCollision, useDom, warn, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  if (typeof jQuery === "undefined" || jQuery === null) {
    throw new Error("jQuery is not defined");
  }

  $ = jQuery;

  error = function(string, deep) {
    if (deep == null) {
      deep = false;
    }
    if (deep) {
      throw new Error(string);
    } else {
      if (typeof console !== "undefined" && console !== null) {
        if (typeof console.error === "function") {
          console.error(string);
        }
      }
    }
  };

  warn = function(string) {
    return typeof console !== "undefined" && console !== null ? typeof console.warn === "function" ? console.warn(string) : void 0 : void 0;
  };

  GameObjectArray = (function(_super) {
    __extends(GameObjectArray, _super);

    function GameObjectArray(original) {
      var item, _i, _len;
      for (_i = 0, _len = original.length; _i < _len; _i++) {
        item = original[_i];
        this.push(item);
      }
    }

    GameObjectArray.prototype.on = function() {
      var obj, _i, _len;
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        obj = this[_i];
        obj.on.apply(obj, arguments);
      }
      return this;
    };

    GameObjectArray.prototype.off = function() {
      var obj, _i, _len;
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        obj = this[_i];
        obj.off.apply(obj, arguments);
      }
      return this;
    };

    GameObjectArray.prototype.unbindCollision = function() {
      var obj, _i, _len;
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        obj = this[_i];
        obj.unbindCollision.apply(obj, arguments);
      }
      return this;
    };

    GameObjectArray.prototype.collides = function() {
      var obj, _i, _len;
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        obj = this[_i];
        obj.collides.apply(obj, arguments);
      }
      return this;
    };

    return GameObjectArray;

  })(Array);

  Idea = function(arg, n, d, f) {
    var b, i, inst, insts, isListOfNumbers, nType, newInsts, obj, theType, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _ref, _ref1, _ref2, _results, _results1;
    theType = $.type(arg);
    nType = $.type(n);
    isListOfNumbers = /^(?:\d,?)+$/;
    if (__indexOf.call(allObjects, arg) >= 0 && __indexOf.call(allRooms, n) >= 0) {
      return n.allInstances[arg.objectId];
    } else if (__indexOf.call(allObjects, arg) >= 0 && (nType === "undefined" || n === "current")) {
      return Idea(arg, room);
    } else if (theType === "undefined" || theType === "null") {
      return allObjects;
    } else if (theType === "number" && nType === "undefined") {
      return allObjects[arg];
    } else if (theType === "number" && n === "current") {
      return Idea(Idea(arg));
    } else if (theType === "number" && __indexOf.call(allRooms, n) >= 0) {
      return Idea(Idea(arg), n);
    } else if (theType === "string") {
      switch (arg) {
        case "iterate":
          return Idea.apply(["iterate forward"].concat([].slice.call(arguments, 1)));
        case "iterate forward":
          insts = Idea(n, d);
          _results = [];
          for (_i = 0, _len = insts.length; _i < _len; _i++) {
            inst = insts[_i];
            _results.push(f.call(inst));
          }
          return _results;
          break;
        case "iterate backward":
          insts = Idea(n, d);
          _results1 = [];
          for (i = _j = _ref = insts.length; _ref <= 0 ? _j < 0 : _j > 0; i = _ref <= 0 ? ++_j : --_j) {
            inst = insts[i - 1];
            _results1.push(f.call(inst));
          }
          return _results1;
          break;
        default:
          if (isListOfNumbers.test(arg)) {
            if (nType === "undefined") {
              b = (function() {
                var _k, _len1, _ref1, _results2;
                _ref1 = arg.split(",");
                _results2 = [];
                for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
                  i = _ref1[_k];
                  _results2.push(Idea(parseInt(i, 10)));
                }
                return _results2;
              })();
              return new GameObjectArray(b);
            } else if (n === "current" || __indexOf.call(allRooms, n) >= 0) {
              b = (function() {
                var _k, _len1, _ref1, _results2;
                _ref1 = arg.split(",");
                _results2 = [];
                for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
                  i = _ref1[_k];
                  _results2.push(parseInt(i, 10));
                }
                return _results2;
              })();
              newInsts = new InstanceArray();
              for (_k = 0, _len1 = b.length; _k < _len1; _k++) {
                obj = b[_k];
                _ref1 = Idea(obj, n);
                for (_l = 0, _len2 = _ref1.length; _l < _len2; _l++) {
                  inst = _ref1[_l];
                  newInsts.push(inst);
                }
              }
              return newInsts;
            }
          } else if (theType === "string" && nType === "undefined") {
            b = byTags[arg];
            if (b == null) {
              if (!settings.suppressTagWarnings) {
                error("Bad tag name");
              }
              return;
            }
            return new GameObjectArray(b);
          } else if (theType === "string" && (n === "current" || __indexOf.call(allRooms, n) >= 0)) {
            b = byTags[arg];
            if (b == null) {
              if (!settings.suppressTagWarnings) {
                error("Bad tag name");
              }
            }
            newInsts = new InstanceArray();
            for (_m = 0, _len3 = b.length; _m < _len3; _m++) {
              obj = b[_m];
              _ref2 = Idea(obj, n);
              for (_n = 0, _len4 = _ref2.length; _n < _len4; _n++) {
                inst = _ref2[_n];
                newInsts.push(inst);
              }
            }
            return newInsts;
          } else {
            return error("Unrecognizable arguments", true);
          }
      }
    }
  };

  Idea.version = "beta";

  fromCharCode = function(chr) {
    var from32to40, letters, ret;
    letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    from32to40 = "space,page up,page down,end,home,left,up,right,down".split(",");
    ret = (function() {
      switch (chr) {
        case 8:
          return "backspace";
        case 9:
          return "tab";
        case 13:
          return "enter";
        case 16:
          return "shift";
        case 17:
          return "ctrl";
        case 18:
          return "alt";
        case 20:
          return "caps lock";
        case 27:
          return "esc";
        case 45:
          return "insert";
        case 46:
          return "delete";
        case 188:
          return ",";
        case 190:
          return ".";
        case 191:
          return "/";
        case 192:
          return "`";
        case 219:
          return "[";
        case 220:
          return "\\";
        case 222:
          return "'";
        default:
          return null;
      }
    })();
    if (!ret) {
      if ((32 <= chr && chr <= 40)) {
        ret = from32to40[chr - 32];
      }
      if ((48 <= chr && chr <= 57)) {
        ret = (chr - 48) + "";
      }
      if ((65 <= chr && chr <= 90)) {
        ret = letters[chr - 65];
      }
      if ((112 <= chr && chr <= 123)) {
        ret = "f" + (chr - 111);
      }
    }
    return ret;
  };

  room = null;

  useDom = false;

  game_screen = null;

  gameWidth = null;

  gameHeight = null;

  game = null;

  backgroundCanvas = null;

  byTags = {};

  modules = [];

  Module = (function() {
    Module.prototype.on = function(events, fn, overwrite) {
      var buffer, selector;
      selector = this.selector;
      buffer = this.buffer;
      if (buffer[selector] == null) {
        buffer[selector] = [];
      }
      buffer[selector].push([events, fn, overwrite]);
      return this;
    };

    function Module(selector) {
      this.selector = selector;
      modules.push(this);
      this.buffer = {};
    }

    return Module;

  })();

  Idea.module = function(tag) {
    return new Module(tag);
  };

  InstanceArray = (function(_super) {
    var fn, fns, prop, props, _fn, _fn1, _i, _j, _len, _len1,
      _this = this;

    __extends(InstanceArray, _super);

    function InstanceArray() {
      InstanceArray.__super__.constructor.apply(this, arguments);
    }

    InstanceArray.prototype.attr = function(str, value) {
      var inst, _i, _len, _ref;
      if ((value != null) || $.type(str) === "object") {
        for (_i = 0, _len = this.length; _i < _len; _i++) {
          inst = this[_i];
          inst.attr.apply(inst, arguments);
        }
        return this;
      } else {
        return (_ref = this[0]).attr.apply(_ref, arguments);
      }
    };

    props = ['x', 'y', 'vx', 'vy', 'useBackCan', 'deactivateOut', 'sprite', 'create', 'begin step', 'draw', 'step', 'end step', 'events', 'collision', 'visible'];

    fns = ['trigger', 'destroy', 'moveUp', 'moveDown', 'moveRight', 'moveLeft', 'fourDirections', 'animate'];

    _fn = function(prop) {
      Object.defineProperty(InstanceArray.prototype, prop, {
        set: function(val) {
          var i, _j, _len1;
          for (_j = 0, _len1 = this.length; _j < _len1; _j++) {
            i = this[_j];
            i[prop] = val;
          }
        },
        get: function(val) {
          var _ref;
          return (_ref = this[0]) != null ? _ref[prop] : void 0;
        }
      });
    };
    for (_i = 0, _len = props.length; _i < _len; _i++) {
      prop = props[_i];
      _fn(prop);
    }

    _fn1 = function(fn) {
      InstanceArray.prototype[fn] = function() {
        var inst, _k, _len2;
        for (_k = 0, _len2 = this.length; _k < _len2; _k++) {
          inst = this[_k];
          inst[fn].apply(inst, arguments);
        }
        return this;
      };
    };
    for (_j = 0, _len1 = fns.length; _j < _len1; _j++) {
      fn = fns[_j];
      _fn1(fn);
    }

    return InstanceArray;

  }).call(this, Array);

  Idea.init = function(xGameWidth, xGameHeight, xUseDom, root) {
    var fps, fpsFilter, gameInterval, lastUpdate, r, xBackgroundCanvas, xGame_screen, _i, _len, _ref, _ref1;
    if (xUseDom == null) {
      xUseDom = false;
    }
    if (root == null) {
      root = "body";
    }
    if (!xUseDom) {
      xGame_screen = $("<canvas width=" + xGameWidth + " height=" + xGameHeight + ">").css({
        "position": "absolute",
        "z-index": 0
      });
      xBackgroundCanvas = $("<canvas width=" + xGameWidth + " height=" + xGameHeight + ">").css({
        "position": "absolute",
        "z-index": -1
      });
      $(root).append(xBackgroundCanvas).append(xGame_screen);
      useDom = false;
      _ref = [xGame_screen[0], xBackgroundCanvas[0]], game_screen = _ref[0], backgroundCanvas = _ref[1];
    } else {
      $(root).css({
        position: "absolute",
        width: xGameWidth,
        height: xGameHeight
      });
      game_screen = $(root)[0];
      useDom = true;
    }
    _ref1 = [xGameWidth, xGameHeight], gameWidth = _ref1[0], gameHeight = _ref1[1];
    (function() {
      var lastTime, vendor, vendors, _i, _len;
      lastTime = 0;
      vendors = ['ms', 'moz', 'webkit', 'o'];
      for (_i = 0, _len = vendors.length; _i < _len; _i++) {
        vendor = vendors[_i];
        if (window.requestAnimationFrame) {
          break;
        }
        window.requestAnimationFrame = window[vendor + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendor + 'CancelAnimationFrame'] || window[vendor + 'CancelRequestAnimationFrame'];
      }
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function(callback, element) {
          var currTime, id, timeToCall;
          currTime = new Date().getTime();
          timeToCall = Math.max(0, 16 - (currTime - lastTime));
          id = window.setTimeout((function() {
            return callback(currTime + timeToCall);
          }), timeToCall);
          lastTime = currTime + timeToCall;
          return id;
        };
        return window.cancelAnimationFrame = function(id) {
          return clearTimeout(id);
        };
      }
    })();
    gameInterval = 0;
    fps = 0;
    lastUpdate = Date.now();
    fpsFilter = 50;
    basicFunctionsStart();
    for (_i = 0, _len = allRooms.length; _i < _len; _i++) {
      r = allRooms[_i];
      r.renderBackPic();
    }
    game = {
      play: function() {
        var fun, module, objs, selector, value, values, _j, _k, _len1, _len2, _ref2,
          _this = this;
        for (_j = 0, _len1 = modules.length; _j < _len1; _j++) {
          module = modules[_j];
          _ref2 = module.buffer;
          for (selector in _ref2) {
            values = _ref2[selector];
            if (module.buffer.hasOwnProperty(selector)) {
              objs = Idea(selector);
              for (_k = 0, _len2 = values.length; _k < _len2; _k++) {
                value = values[_k];
                objs.on.apply(objs, value);
              }
            }
          }
        }
        fun = function() {
          var now, thisFrameFPS;
          gameInterval = requestAnimationFrame(fun);
          if (Idea.assetsLoaded === assets.length) {
            if (!_this.loaded) {
              _this.loaded = true;
              _this.finishLoad();
            }
            if (room != null) {
              room.refresh();
            }
            basicFunctionsEnd();
            thisFrameFPS = 1000 / ((now = Date.now()) - lastUpdate);
            fps += (thisFrameFPS - fps) / fpsFilter;
            return lastUpdate = now;
          } else {
            return _this.load(Idea.assetsLoaded / assets.length);
          }
        };
        return gameInterval = requestAnimationFrame(fun);
      },
      fps: function() {
        if (fps !== fps) {
          return fps = 60;
        } else {
          return fps;
        }
      },
      pause: function() {
        return cancelAnimationFrame(gameInterval);
      },
      load: function(progress) {
        var ctx, x, y;
        ctx = game_screen.getContext("2d");
        ctx.save();
        ctx.fillStyle = settings.loadColor;
        ctx.strokeStyle = settings.loadColor;
        x = gameWidth / 2 - 50;
        y = gameHeight / 2 - 25;
        ctx.fillRect(x, y, progress * 100, 50);
        ctx.strokeRect(x, y, 100, 50);
        return ctx.restore();
      },
      finishLoad: function() {
        return room != null ? typeof room.refreshBackground === "function" ? room.refreshBackground() : void 0 : void 0;
      },
      loaded: false
    };
    return game;
  };

  Idea.game = function() {
    return game;
  };

  Idea.settings = settings = {
    bufferDestroy: true,
    bufferRoomGoto: true,
    suppressAudioWarnings: false,
    suppressTagWarnings: false,
    suppressAlarmWarnings: false,
    loadColor: "red"
  };

  Idea.controls = controls = {
    keyControls: function(fnDown, fnUp) {
      return $(document).keydown(fnDown).keyup(fnUp);
    },
    mouseControls: function(fnDown, fnUp, fnMove) {
      return $(game_screen).mousedown(fnDown).mouseup(fnUp).mousemove(fnMove);
    }
  };

  Idea.support = support = {
    audio: "Audio" in window,
    canvas: ((_ref = document.createElement("canvas")) != null ? _ref.tagName : void 0) != null ? true : false
  };

  Idea.getScreen = function() {
    return game_screen;
  };

  Idea.getCanvasContext = function() {
    return typeof game_screen.getContext === "function" ? game_screen.getContext("2d") : void 0;
  };

  Idea.getBackCanContext = function() {
    return typeof backgroundCanvas.getContext === "function" ? backgroundCanvas.getContext("2d") : void 0;
  };

  Idea.getBackgroundCanvas = function() {
    return backgroundCanvas;
  };

  Idea.gameWidth = function() {
    return gameWidth;
  };

  Idea.gameHeight = function() {
    return gameHeight;
  };

  Idea.defineSettings = function(newSettings) {
    return $.extend(settings, newSettings);
  };

  Idea.allObjects = allObjects = [];

  trigger = function() {
    var args, caller, fn, fns, methods, _i, _len, _results;
    caller = arguments[0], methods = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    fns = caller[methods];
    switch ($.type(fns)) {
      case "function":
        return fns.apply(caller, args);
      case "array":
        _results = [];
        for (_i = 0, _len = fns.length; _i < _len; _i++) {
          fn = fns[_i];
          _results.push(fn.apply(caller, args));
        }
        return _results;
        break;
      default:
        return false;
    }
  };

  triggerCollision = function() {
    var args, caller, method, methods, _i, _len, _results;
    caller = arguments[0], methods = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    switch ($.type(methods)) {
      case "function":
        return methods.apply(caller, args);
      case "array":
        _results = [];
        for (_i = 0, _len = methods.length; _i < _len; _i++) {
          method = methods[_i];
          _results.push(method.apply(caller, args));
        }
        return _results;
        break;
      default:
        return false;
    }
  };

  Idea.gameObject = function(args, tags) {
    var gmInstance, newAngles;
    if (tags == null) {
      tags = [];
    }
    if (__indexOf.call(tags, "*") < 0) {
      tags.push("*");
    }
    newAngles = function(x, y, degrees, centerX, centerY) {
      var theta, x2, y2;
      theta = degrees / 360 * (Math.PI * 2);
      x2 = centerX + (x - centerX) * Math.cos(Math.PI * 2 - theta) + (y - centerY) * Math.sin(Math.PI * 2 - theta);
      y2 = centerY - (x - centerX) * Math.sin(Math.PI * 2 - theta) + (y - centerY) * Math.cos(Math.PI * 2 - theta);
      return [x2, y2];
    };
    gmInstance = (function() {
      var i, _i, _len;

      function gmInstance(gx, gy) {
        var _ref1, _ref2, _ref3, _ref4;
        if ((_ref1 = this.sprite) != null ? _ref1.useDom : void 0) {
          this.statics = this.useBackCan = false;
        }
        if ((_ref2 = this.sprite) != null) {
          _ref2.createDiv();
        }
        if (this.width == null) {
          this.width = (_ref3 = this.sprite) != null ? _ref3.width : void 0;
        }
        if (this.height == null) {
          this.height = (_ref4 = this.sprite) != null ? _ref4.height : void 0;
        }
        if (this.statics) {
          this.deactivateOut = true;
          this.useBackCan = true;
        }
        room.allInstances[gmInstance.objectId].push(this);
        if (this.useBackCan) {
          room.staticInst.push(this);
        }
        this.animQueue = [];
        this.currentQueue = 0;
        this.constructor = gmInstance;
        this.prevX = this.x = gx;
        this.prevY = this.y = gy;
        this.vx = this.vy = 0;
        this.created = false;
        this.imgAngle = 0;
        this.imgScaleX = this.imgScaleY = 1;
        this.id = room.allInstances[gmInstance.objectId].length;
      }

      gmInstance.prototype.statics = false;

      gmInstance.prototype.sprite = null;

      gmInstance.prototype.visible = true;

      gmInstance.prototype.width = null;

      gmInstance.prototype.deactivateOut = false;

      gmInstance.prototype.useBackCan = false;

      gmInstance.prototype.deactivateOut = false;

      gmInstance.prototype.visible = true;

      gmInstance.prototype.animate = function(props, frames) {
        if (frames == null) {
          frames = 200;
        }
        this.animQueue.push([props, frames]);
        return this;
      };

      gmInstance.prototype.attr = function(str, value) {
        var key;
        if ((value != null) && $.type(str) === "string") {
          this[str] = value;
          return this;
        } else if ($.type(str) === "object") {
          for (key in str) {
            if (str.hasOwnProperty(key)) {
              this[key] = str[key];
            }
          }
          return this;
        } else {
          return this[str];
        }
      };

      gmInstance.prototype.nullified = false;

      gmInstance.prototype.destroy = function(buffer) {
        var ind, ind2, insts, obj, _ref1, _ref2;
        if (buffer == null) {
          buffer = settings.bufferDestroy;
        }
        if (buffer) {
          room.toDestroy.push(this);
          return;
        }
        obj = this.constructor;
        if ((_ref1 = this.sprite) != null ? _ref1.useDom : void 0) {
          if ((_ref2 = $(".divSprite" + this.sprite.id + ":eq(" + (this.id - 1) + ")")) != null) {
            _ref2.remove();
          }
        }
        insts = Idea(obj, room);
        ind = insts.indexOf(this);
        if (__indexOf.call(room.staticInst, this) >= 0) {
          ind2 = room.staticInst.indexOf(this);
          room.staticInst.splice(ind2, 1);
        }
        insts.splice(ind, 1);
      };

      gmInstance.prototype.mask = function() {
        var newangles, newangles2, newangles3, newangles4, objx, objy;
        if (this.imgAngle === 0) {
          return {
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.height
          };
        }
        newangles = newAngles(this.x, this.y, this.imgAngle, this.x + this.width / 2, this.y + this.height / 2);
        newangles2 = newAngles(this.x + this.width, this.y + this.height, this.imgAngle, this.x + this.width / 2, this.y + this.height / 2);
        newangles3 = newAngles(this.x, this.y + this.height, this.imgAngle, this.x + this.width / 2, this.y + this.height / 2);
        newangles4 = newAngles(this.x + this.height, this.y, this.imgAngle, this.x + this.width / 2, this.y + this.height / 2);
        objx = Math.min(newangles[0], newangles2[0], newangles3[0], newangles4[0]);
        objy = Math.min(newangles[1], newangles2[1], newangles3[1], newangles4[1]);
        return {
          x: objx,
          y: objy,
          width: (Math.max(newangles[0], newangles2[0], newangles3[0], newangles4[0])) - objx,
          height: (Math.max(newangles[1], newangles2[1], newangles3[1], newangles4[1])) - objy
        };
      };

      gmInstance.prototype.moveUp = function() {
        var _ref1;
        (_ref1 = this.constructor).moveUp.apply(_ref1, arguments);
        return this;
      };

      gmInstance.prototype.moveDown = function() {
        var _ref1;
        (_ref1 = this.constructor).moveDown.apply(_ref1, arguments);
        return this;
      };

      gmInstance.prototype.moveLeft = function() {
        var _ref1;
        (_ref1 = this.constructor).moveLeft.apply(_ref1, arguments);
        return this;
      };

      gmInstance.prototype.moveRight = function() {
        var _ref1;
        (_ref1 = this.constructor).moveRight.apply(_ref1, arguments);
        return this;
      };

      gmInstance.prototype.fourDirections = function() {
        var _ref1;
        (_ref1 = this.constructor).fourDirections.apply(_ref1, arguments);
        return this;
      };

      gmInstance.prototype.stopMovement = function() {
        this.vx = this.vy = 0;
        this.x = this.prevX;
        return this.y = this.prevY;
      };

      gmInstance.prototype.glideTo = function(ox, oy, speed) {
        var difX, difY, n, x, y, _ref1, _ref2;
        if (speed == null) {
          speed = 1;
        }
        _ref1 = [this.x, this.y], x = _ref1[0], y = _ref1[1];
        difX = x - ox;
        difY = y - oy;
        n = Math.sqrt((difX * difX + difY * difY) / (speed * speed));
        return _ref2 = [difX / n, difY / n], this.vx = _ref2[0], this.vy = _ref2[1], _ref2;
      };

      gmInstance.prototype.draw = function(ctx) {
        var _ref1, _ref2;
        if ((_ref1 = this.sprite) != null) {
          _ref1.draw(ctx, this.x, this.y, this.id);
        }
        return (_ref2 = this.sprite) != null ? _ref2.refreshAnimation(room.allInstances[this.constructor.objectId][0] === this) : void 0;
      };

      gmInstance.prototype.collision = {};

      gmInstance.prototype.direction = function(vx, vy) {
        var degrees;
        if (vx == null) {
          vx = this.vx;
        }
        if (vy == null) {
          vy = this.vy;
        }
        degrees = Math.atan2(vy, vx) * 180 / Math.PI;
        return ((degrees + 360) % 360) % 360;
      };

      gmInstance.prototype.speed = function(vx, vy) {
        if (vx == null) {
          vx = this.vx;
        }
        if (vy == null) {
          vy = this.vy;
        }
        return Math.sqrt(vx * vx + vy * vy);
      };

      gmInstance.prototype.trigger = function() {
        return trigger.apply(null, [this].concat(__slice.call(arguments)));
      };

      gmInstance.prototype.events = function() {
        var c, ctx, frames, i, ind, insideView, inst, insts, key, obj, prop, props, queue, toSplice, value, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref1, _ref2, _ref3, _ref4, _ref5,
          _this = this;
        if (!this.created) {
          this.created = true;
          trigger(this, "create");
        }
        trigger(this, "begin step");
        if (!useDom) {
          ctx = game_screen.getContext('2d');
        }
        insideView = collisionRect(this.mask(), (function() {
          var v;
          v = room.view();
          return {
            x: v[0],
            y: v[1],
            width: gameWidth,
            height: gameHeight
          };
        })());
        this.visible = insideView;
        if (!insideView && this.deactivateOut) {
          room.deactivated.push(this);
          insts = Idea(gmInstance, room);
          ind = insts.indexOf(this);
          insts.splice(ind, 1);
          if (this.sprite.useDom) {
            $(".divSprite" + this.sprite.id + ":eq(" + (this.id - 1) + ")").css("display", "none");
          }
          return;
        }
        if (insideView && this.deactivateOut && useDom) {
          $(".divSprite" + this.sprite.id + ":eq(" + (this.id - 1) + ")").css("display", "block");
        }
        if ((this.draw != null) && !this.useBackCan) {
          if (useDom) {
            trigger(this, "draw", game_screen);
          } else {
            ctx.save();
            ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
            ctx.rotate(this.imgAngle * Math.PI / 180);
            ctx.scale(this.imgScaleX, this.imgScaleY);
            ctx.translate(-(this.x + this.width / 2), -(this.y + this.height / 2));
            trigger(this, "draw", ctx);
            ctx.restore();
          }
        }
        if (this.nullified) {
          return false;
        }
        trigger(this, "step");
        toSplice = [];
        queue = this.animQueue[0];
        if (queue) {
          props = queue[0], frames = queue[1];
          for (prop in props) {
            value = props[prop];
            this[prop] += (value - this[prop]) / frames;
            if (Math.abs(this[prop] - props[prop]) < 0.001) {
              delete props[prop];
            }
          }
          queue[1]--;
          if ($.isEmptyObject(queue[0])) {
            this.animQueue.splice(0, 1);
          }
        }
        for (i in (_ref1 = this.collision) != null ? _ref1 : {}) {
          if (!this.collision.hasOwnProperty(i)) {
            continue;
          }
          obj = allObjects[parseInt(i, 10)];
          _ref2 = room.allInstances[obj.objectId];
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            inst = _ref2[_i];
            if (inst.nullified) {
              continue;
            }
            c = collisionRect(inst.mask(), this.mask());
            if (c) {
              triggerCollision(this, this.collision[i], inst, c);
            }
          }
        }
        (function() {
          if (_this.x + _this.width > room.w) {
            trigger(_this, "intersect boundary", "right");
          }
          if (_this.y + _this.height > room.h) {
            trigger(_this, "intersect boundary", "bottom");
          }
          if (_this.x < 0) {
            trigger(_this, "intersect boundary", "left");
          }
          if (_this.y < 0) {
            return trigger(_this, "intersect boundary", "top");
          }
        })();
        (function() {
          if (_this.x > room.w) {
            trigger(_this, "outside room", "right");
          }
          if (_this.x + _this.width < 0) {
            trigger(_this, "outside room", "left");
          }
          if (_this.y > room.h) {
            trigger(_this, "outside room", "bottom");
          }
          if (_this.y + _this.height < 0) {
            return trigger(_this, "outside room", "top");
          }
        })();
        (function() {
          var intr, outs, theView;
          theView = {
            x: room.view()[0],
            y: room.view()[1],
            left: room.view()[0] + gameWidth,
            bottom: room.view()[1] + gameHeight
          };
          intr = _this["intersect view"];
          outs = _this["outside view"];
          if (_this.x + _this.width > theView.left) {
            trigger(_this, "intersect view", "right");
          }
          if (_this.y + _this.height > theView.bottom) {
            trigger(_this, "intersect view", "bottom");
          }
          if (_this.x < theView.x) {
            trigger(_this, "intersect view", "left");
          }
          if (_this.y < theView.y) {
            trigger(_this, "intersect view", "top");
          }
          if (_this.x > theView.w) {
            trigger(_this, "outside view", "right");
          }
          if (_this.x + _this.width < theView.x) {
            trigger(_this, "outside view", "left");
          }
          if (_this.y > theView.bottom) {
            trigger(_this, "outside view", "bottom");
          }
          if (_this.y + _this.height < theView.y) {
            return trigger(_this, "outside view", "top");
          }
        })();
        _ref3 = Idea.globalKeysdown;
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          key = _ref3[_j];
          trigger(this, "keydown-" + (fromCharCode(key)));
        }
        _ref4 = Idea.globalKeysup;
        for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
          key = _ref4[_k];
          trigger(this, "keyup-" + (fromCharCode(key)));
        }
        _ref5 = Idea.globalKeyspressed;
        for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
          key = _ref5[_l];
          trigger(this, "keypressed-" + (fromCharCode(key)));
        }
        if (Idea.globalMousedown) {
          trigger(this, "mousedown-" + Idea.globalMousedown);
        }
        if (Idea.globalMousepressed) {
          trigger(this, "mousepressed-" + Idea.globalMousepressed);
        }
        if (Idea.globalMouseup) {
          trigger(this, "mouseup-" + Idea.globalMouseup);
        }
        this.prevX = this.x;
        this.prevY = this.y;
        this.x += this.vx;
        this.y += this.vy;
        trigger(this, "end step");
      };

      allObjects.push(gmInstance);

      gmInstance.objectId = allObjects.length - 1;

      allRooms.forEach(function(v, i, l) {
        return l[i].allInstances.push(new InstanceArray());
      });

      for (_i = 0, _len = tags.length; _i < _len; _i++) {
        i = tags[_i];
        if (byTags[i] != null) {
          byTags[i].push(gmInstance);
        } else {
          byTags[i] = [gmInstance];
        }
      }

      gmInstance.on = function(_events, fn, overwrite) {
        var event, events, inst, isCollisionEvent, pr, _j, _k, _len1, _len2, _ref1, _with;
        if (overwrite == null) {
          overwrite = false;
        }
        events = _events.split(", ");
        isCollisionEvent = "collision-with-";
        for (_j = 0, _len1 = events.length; _j < _len1; _j++) {
          event = events[_j];
          if (event.indexOf(isCollisionEvent) === 0) {
            _with = event.slice(isCollisionEvent.length);
            this.collides(_with, fn, overwrite);
            continue;
          }
          pr = this.prototype[event];
          if ((pr == null) || overwrite) {
            this.prototype[event] = fn;
          } else if ($.type(pr) === "function") {
            this.prototype[event] = [pr, fn];
          } else if ($.type(pr) === "array") {
            pr.push(fn);
          }
          if (room != null) {
            _ref1 = Idea(this, "current");
            for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
              inst = _ref1[_k];
              if (inst.hasOwnProperty(event)) {
                delete inst[event];
              }
            }
          }
        }
        return this;
      };

      gmInstance.collides = function(_with, fn, overwrite) {
        var inst, oObj, obj, objs, pr, w, _j, _k, _l, _len1, _len2, _len3, _ref1;
        if (overwrite == null) {
          overwrite = false;
        }
        if (this.collision == null) {
          this.collision = {};
        }
        if ($.type(_with) === "function") {
          _with = _with.objectId.toString();
        }
        w = _with.split(", ");
        for (_j = 0, _len1 = w.length; _j < _len1; _j++) {
          obj = w[_j];
          if ((parseInt(obj, 10)) === (parseInt(obj, 10))) {
            pr = this.prototype.collision[obj];
            if ((pr == null) || overwrite) {
              this.prototype.collision[obj] = fn;
            } else if ($.type(pr) === "function") {
              this.prototype.collision[obj] = [pr, fn];
            } else if ($.type(pr) === "array") {
              pr.push(fn);
            }
          } else {
            objs = Idea(obj);
            for (_k = 0, _len2 = objs.length; _k < _len2; _k++) {
              oObj = objs[_k];
              pr = this.prototype.collision[oObj.objectId];
              if ((pr == null) || overwrite) {
                this.prototype.collision[oObj.objectId] = fn;
              } else if ($.type(pr) === "function") {
                this.prototype.collision[oObj.objectId] = [pr, fn];
              } else if ($.type(pr) === "array") {
                pr.push(fn);
              }
            }
          }
          if (room != null) {
            _ref1 = Idea(this);
            for (_l = 0, _len3 = _ref1.length; _l < _len3; _l++) {
              inst = _ref1[_l];
              delete inst.collision;
            }
          }
        }
        return this;
      };

      gmInstance.moveUp = function(speed, callback, key) {
        if (speed == null) {
          speed = 1;
        }
        if (key == null) {
          key = "up";
        }
        if ($.type(callback) === "string") {
          key = callback;
        }
        this.on("keydown-" + key, function() {
          this.vy = -speed;
          return typeof callback === "function" ? callback("up") : void 0;
        });
        this.on("keyup-" + key, function() {
          return this.vy = 0;
        });
        return this;
      };

      gmInstance.moveDown = function(speed, callback, key) {
        if (speed == null) {
          speed = 1;
        }
        if (key == null) {
          key = "down";
        }
        if ($.type(callback) === "string") {
          key = callback;
        }
        this.on("keydown-" + key, function() {
          this.vy = speed;
          return typeof callback === "function" ? callback("down") : void 0;
        });
        this.on("keyup-" + key, function() {
          return this.vy = 0;
        });
        return this;
      };

      gmInstance.moveLeft = function(speed, callback, key) {
        if (speed == null) {
          speed = 1;
        }
        if (key == null) {
          key = "left";
        }
        if ($.type(callback) === "string") {
          key = callback;
        }
        this.on("keydown-" + key, function() {
          this.vx = -speed;
          return typeof callback === "function" ? callback("left") : void 0;
        });
        this.on("keyup-" + key, function() {
          return this.vx = 0;
        });
        return this;
      };

      gmInstance.moveRight = function(speed, callback, key) {
        if (speed == null) {
          speed = 1;
        }
        if (key == null) {
          key = "right";
        }
        if ($.type(callback) === "string") {
          key = callback;
        }
        this.on("keydown-" + key, function() {
          this.vx = speed;
          return typeof callback === "function" ? callback("right") : void 0;
        });
        this.on("keyup-" + key, function() {
          return this.vx = 0;
        });
        return this;
      };

      gmInstance.fourDirections = function(speed, callback, keys) {
        if (keys == null) {
          keys = ["up", "down", "left", "right"];
        }
        if ($.type(callback) === "array") {
          keys = callback;
        }
        this.moveUp(speed, callback, keys[0]).moveDown(speed, callback, keys[1]).moveLeft(speed, callback, keys[2]).moveRight(speed, callback, keys[3]);
        return this;
      };

      $.extend(gmInstance.prototype, args);

      gmInstance.off = function(_events, method) {
        var event, events, index, isCollisionEvent, pr, subFire, _j, _k, _len1, _len2, _ref1, _ref2, _with;
        events = _events.split(", ");
        isCollisionEvent = "collision-with-";
        for (_j = 0, _len1 = events.length; _j < _len1; _j++) {
          event = events[_j];
          if (event.indexOf(isCollisionEvent) === 0) {
            _with = event.slice(isCollisionEvent.length);
            if (typeof this.unbindCollision === "function") {
              this.unbindCollision(_with, method);
            }
          } else if (method != null) {
            if (method === this.prototype[event]) {
              this.prototype[event] = null;
            } else {
              _ref1 = this.prototype[event];
              for (index = _k = 0, _len2 = _ref1.length; _k < _len2; index = ++_k) {
                subFire = _ref1[index];
                if (subFire === method) {
                  this.prototype[event].splice(index, 1);
                  break;
                }
              }
            }
          } else {
            pr = this.prototype[event];
            if ($.type(pr) === "function") {
              this.prototype[event] = null;
            } else if ($.type(pr) === "array") {
              if ((_ref2 = this.prototype[event]) != null) {
                _ref2.splice(0, 9e9);
              }
            }
          }
        }
        return this;
      };

      gmInstance.unbindCollision = function(_with, method) {
        var ind, inst, oObj, obj, objs, pr, subFire, w, _j, _k, _l, _len1, _len2, _len3, _ref1, _results;
        if ($.type(_with) === "function") {
          _with = _with.objectId.toString();
        }
        w = _with.split(", ");
        _results = [];
        for (_j = 0, _len1 = w.length; _j < _len1; _j++) {
          obj = w[_j];
          if ((parseInt(obj, 10)) === (parseInt(obj, 10))) {
            pr = this.prototype.collision[obj];
            if (method != null) {
              if (pr === method) {
                this.prototype.collision[obj] = null;
              } else {
                for (ind = _k = 0, _len2 = pr.length; _k < _len2; ind = ++_k) {
                  subFire = pr[ind];
                  if (subFire === method) {
                    this.prototype[event].splice(ind, 1);
                    break;
                  }
                }
              }
            } else {
              if ($.type(pr) === "function") {
                this.prototype.collision[obj] = null;
              } else if ($.type(pr) === "array") {
                if ((_ref1 = this.prototype.collision[obj]) != null) {
                  _ref1.splice(0, 9e9);
                }
              }
            }
          } else {
            objs = Idea(obj);
            for (_l = 0, _len3 = objs.length; _l < _len3; _l++) {
              oObj = objs[_l];
              this.unbindCollision(oObj, method);
            }
          }
          if (room != null) {
            _results.push((function() {
              var _len4, _m, _ref2, _results1;
              _ref2 = Idea(this);
              _results1 = [];
              for (_m = 0, _len4 = _ref2.length; _m < _len4; _m++) {
                inst = _ref2[_m];
                _results1.push(delete inst.collision);
              }
              return _results1;
            }).call(this));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };

      return gmInstance;

    })();
    return gmInstance;
  };

  Idea.getByTags = function() {
    return byTags;
  };

  Idea.assets = assets = [];

  Idea.assetsLoaded = 0;

  playingSounds = [];

  newAudio = function() {
    return (new Audio()) || document.createElement("Audio");
  };

  Sound = (function() {
    Sound.prototype.trackID = 0;

    function Sound(src, numTracks, onload) {
      var cpt, ending, i, maybes, _i, _len, _ref1, _ref2,
        _this = this;
      if (numTracks == null) {
        numTracks = 3;
      }
      if (!support.audio) {
        return;
      }
      this.unusedTracks = [];
      this.tracks = [];
      this.loadedTracks = [];
      if ($.type(src) === "object") {
        _ref1 = [src.source, src.tracks, src.onload], src = _ref1[0], numTracks = _ref1[1], onload = _ref1[2];
      }
      if ($.type(numTracks) === "function") {
        _ref2 = [numTracks, 5], onload = _ref2[0], numTracks = _ref2[1];
      }
      this.loaded = false;
      this.sound = newAudio();
      if ($.type(src) === "array") {
        maybes = [];
        for (_i = 0, _len = src.length; _i < _len; _i++) {
          i = src[_i];
          ending = i.substr((i.lastIndexOf(".")) + 1);
          cpt = this.sound.canPlayType("audio/" + ending);
          if (cpt === "probably" && ending !== "wav") {
            src = i;
            break;
          } else if (cpt === "maybe" || ending === "wav") {
            maybes.push(i);
          }
        }
        if ($.type(src) === "array") {
          src = maybes[0];
          if (src.substr(src.lastIndexOf(".") + 1) === "wav" && (maybes[1] != null)) {
            src = maybes[1];
          }
          if (src == null) {
            if (!settings.suppressAudioWarnings) {
              warn("No audio file formats were found applicable");
            }
            src = src[0];
          }
        }
      }
      $(this.sound).on("canplaythrough", function() {
        var ii, _fn, _j;
        if (_this.loaded) {
          return;
        }
        Idea.assetsLoaded++;
        _this.loaded = true;
        if (onload != null) {
          onload.call(_this);
        }
        if (_this.sound.duration > 5 && _this.sound.src.substr(_this.sound.src.lastIndexOf(".") + 1) === "wav") {
          _this.tracks = [_this.sound];
          _this.unusedTracks = [0];
          if (!settings.suppressAudioWarnings) {
            warn("Wav files are too big to load many. (Only one track will be loaded.)                Convert to ogg or mp3");
          }
        } else {
          _fn = function(ii) {
            $(_this.tracks[ii]).on("canplaythrough", function() {
              if (!_this.loadedTracks[ii]) {
                _this.loadedTracks[ii] = true;
                Idea.assetsLoaded++;
              }
            });
          };
          for (ii = _j = 0; _j < numTracks; ii = _j += 1) {
            _this.unusedTracks.push(ii);
            _this.tracks[ii] = newAudio();
            assets.push(_this.tracks[ii]);
            _fn(ii);
            _this.loadedTracks[ii] = false;
            _this.tracks[ii].src = src;
            _this.tracks[ii].preload = true;
          }
        }
      });
      this.sound.src = src;
      this.sound.preload = true;
      this.sound.load();
      assets.push(this.sound);
    }

    Sound.prototype.play = function(trackId) {
      var spliced,
        _this = this;
      if (trackId == null) {
        trackId = this.trackID;
      }
      if (this.tracks[trackId] == null) {
        if (!settings.suppressAudioWarnings) {
          error("Not enough tracks");
        }
        return;
      }
      this.tracks[trackId].play();
      $(this.tracks[trackId]).on("ended pause", function() {
        if (__indexOf.call(_this.unusedTracks, spliced) < 0) {
          _this.unusedTracks.push(spliced);
        }
        $(_this).off("ended pause");
        return _this.trackID = _this.unusedTracks[0];
      });
      spliced = this.unusedTracks.splice(this.unusedTracks.indexOf(trackId), 1)[0];
      this.trackID = this.unusedTracks[0];
      return trackId;
    };

    Sound.prototype.stop = function(trackId) {
      var track, _i, _len, _ref1;
      if (trackId == null) {
        _ref1 = this.tracks;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          track = _ref1[_i];
          track.pause();
        }
      } else {
        this.tracks[trackId].pause();
      }
      this.trackID = this.unusedTracks[0];
      return this.unusedTracks;
    };

    Sound.prototype.loop = function(trackId) {
      var spliced,
        _this = this;
      if (trackId == null) {
        trackId = this.trackID;
      }
      if (this.tracks[trackId] == null) {
        if (!settings.suppressAudioWarnings) {
          error("Not enough tracks");
        }
        return;
      }
      this.tracks[trackId].loop = true;
      this.tracks[trackId].play();
      $(this.tracks[trackId]).off("ended pause").on("pause", function() {
        _this.unusedTracks.push(spliced);
        return $(_this).off("ended pause");
      });
      spliced = this.unusedTracks.splice(this.unusedTracks.indexOf(trackId), 1)[0];
      this.trackID = this.unusedTracks[0];
      return trackId;
    };

    return Sound;

  })();

  Idea.Sound = Sound;

  Idea.playingSounds = function() {
    return playingSounds;
  };

  Idea.alarms = alarms = [];

  Alarm = (function() {
    function Alarm(frames, onFinish) {
      alarms.push(this);
      this.onEnd = onFinish != null ? [onFinish] : [];
      this.value = frames;
      this.startValue = frames;
    }

    Alarm.prototype.end = function(fn) {
      this.onEnd.push(fn);
      return this;
    };

    Alarm.prototype.startOver = function(frames) {
      if (frames == null) {
        frames = this.startValue;
      }
      this.value = frames;
      return this;
    };

    Alarm.prototype.trigger = function() {
      var fn, _i, _len, _ref1;
      _ref1 = this.onEnd;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        fn = _ref1[_i];
        fn.call(this);
      }
      return this;
    };

    return Alarm;

  })();

  Idea.Alarm = Alarm;

  Idea.removeAlarm = removeAlarm = function(alarm) {
    var allAlarms;
    allAlarms = alarms;
    if ($.type(alarm) === "number") {
      return allAlarms.splice(alarm, 1);
    } else {
      if (__indexOf.call(allAlarms, alarm) < 0) {
        if (!settings.suppressAlarmWarnings) {
          error("Alarm not found!");
        }
        return;
      }
      return allAlarms.splice(allAlarms.indexOf(alarm), 1);
    }
  };

  Idea.removeAllAlarms = function() {
    var _results;
    _results = [];
    while (this.alarms[0]) {
      _results.push(removeAlarm(0));
    }
    return _results;
  };

  Idea.animation = function(divider, x, y, width, height) {
    var w, _i, _ref1, _results;
    if ($.type(divider) === "object") {
      _ref1 = divider, divider = _ref1.divider, x = _ref1.x, y = _ref1.y, width = _ref1.width, height = _ref1.height;
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
    }
    if (!((width != null) && (height != null))) {
      width = x;
      height = y;
      x = y = 0;
    }
    _results = [];
    for (w = _i = 0; divider > 0 ? _i < width : _i > width; w = _i += divider) {
      _results.push([x + w, y, divider, height]);
    }
    return _results;
  };

  Sprite = (function() {
    var createRepeating, ids, loadFunction, loadSrc, setSize;

    ids = 0;

    setSize = function(elem, width, height) {
      if (elem.tagName.toLowerCase() === "canvas") {
        elem.width = width;
        return elem.height = height;
      } else {
        return $(elem).css({
          width: width,
          height: height,
          position: "absolute"
        });
      }
    };

    createRepeating = function(args) {
      var context, newCanvas, pattern;
      newCanvas = document.createElement("canvas");
      newCanvas.width = args.screen.width;
      newCanvas.height = args.screen.height;
      context = newCanvas.getContext("2d");
      pattern = context.createPattern(args.screen, args.repeating === true ? "repeat" : args.repeating);
      context.rect(0, 0, newCanvas.width, newCanvas.height);
      context.fillStyle = pattern;
      context.fill();
      return newCanvas;
    };

    loadFunction = function(args) {
      var newCanvas;
      args.fn(args.screen);
      newCanvas = args.screen;
      if (!(args._useDom || args.repeating === false)) {
        newCanvas = createRepeating(args);
      }
      return newCanvas;
    };

    loadSrc = function(args) {
      var context, img, newCanvas,
        _this = this;
      img = new Image();
      newCanvas = args.screen;
      if (!args._useDom) {
        context = newCanvas.getContext("2d");
      }
      img.onload = function() {
        var pattern, _ref1;
        if (!args.repeating) {
          if (_this.width == null) {
            _this.width = img.width;
          }
          if (_this.height == null) {
            _this.height = img.height;
          }
          newCanvas.width = _this.width;
          newCanvas.height = _this.height;
          if (args._useDom) {
            newCanvas.appendChild(img);
          } else {
            context.drawImage(img, 0, 0, _this.width, _this.height);
          }
        } else {
          if (args._useDom) {
            error("DOM elements cannot have patterns", true);
          }
          pattern = context.createPattern(img, args.repeating === true ? "repeat" : args.repeating);
          context.rect(0, 0, _this.width, _this.height);
          context.fillStyle = pattern;
          context.fill();
        }
        Idea.assetsLoaded += 1;
        return (_ref1 = args.onload) != null ? _ref1.apply(_this) : void 0;
      };
      img.src = args.source;
      assets.push(img);
      return img;
    };

    function Sprite(args) {
      var newSource, offsetX, offsetY, onload, passArgs, repeating, source, tiles, tilesize, _useDom,
        _this = this;
      this.id = ids;
      ids++;
      if ($.type(args) === "string") {
        args = {
          source: args
        };
      }
      source = args.source, this.width = args.width, this.height = args.height, repeating = args.repeating, onload = args.onload, this.speed = args.speed, _useDom = args._useDom, tilesize = args.tilesize, tiles = args.tiles;
      if (repeating == null) {
        repeating = false;
      }
      if (this.speed == null) {
        this.speed = 1;
      }
      if (_useDom == null) {
        _useDom = false;
      }
      if (tilesize == null) {
        tilesize = 1;
      }
      passArgs = {
        source: source,
        width: this.width,
        height: this.height,
        repeating: repeating,
        onload: onload,
        speed: this.speed,
        _useDom: _useDom,
        tilesize: tilesize,
        tiles: tiles
      };
      this.screen = document.createElement(_useDom ? "div" : "canvas");
      if ((this.width != null) && (this.height != null)) {
        setSize(this.screen, this.width, this.height);
      }
      if ($.type(source) === "function") {
        this.type = "function";
        this.screen = loadFunction.call(this, {
          fn: source,
          width: this.width,
          height: this.height,
          repeating: repeating,
          onload: onload,
          speed: this.speed,
          _useDom: _useDom,
          tilesize: tilesize,
          tiles: tiles,
          screen: this.screen
        });
      } else if (tiles != null) {
        if (_useDom) {
          error("Cannot use tiles with DOM elements", true);
        }
        if ($.type(tiles[0]) !== "array") {
          offsetX = tiles[0] * tilesize;
          offsetY = tiles[1] * tilesize;
          this.screen.width = this.width = tiles[2] * tilesize;
          this.screen.height = this.height = tiles[3] * tilesize;
          _this = this;
          newSource = new Sprite({
            source: source,
            onload: function() {
              return this.draw(_this.screen.getContext("2d"), -offsetX, -offsetY, 1);
            }
          });
          this.type = "tileset";
        } else {
          if (this.width == null) {
            this.width = tiles[0][2] * tilesize;
          }
          if (this.height == null) {
            this.height = tiles[0][3] * tilesize;
          }
          this.imgs = tiles.map(function(tile) {
            return new Sprite({
              source: source,
              width: _this.width,
              height: _this.height,
              repeating: repeating,
              onload: onload,
              speed: _this.speed,
              _useDom: _useDom,
              tilesize: tilesize,
              tiles: tile
            });
          });
          this.imgInd = 0;
          this.type = "animation";
        }
      } else if ($.type(source) === "array") {
        this.type = "animation";
        if (_useDom) {
          error("Cannot create animation with DOM elements", true);
        }
        this.imgs = source.map(function(src) {
          return new Sprite({
            source: src,
            width: _this.width,
            height: _this.height,
            repeating: repeating,
            onload: onload,
            speed: _this.speed,
            _useDom: _useDom,
            tilesize: tilesize,
            tiles: tiles
          });
        });
        this.imgInd = 0;
      } else if ($.type(source) === "string") {
        this.type = "src";
        loadSrc.call(this, {
          source: source,
          width: this.width,
          height: this.height,
          repeating: repeating,
          onload: onload,
          speed: this.speed,
          _useDom: _useDom,
          tilesize: tilesize,
          tiles: tiles,
          screen: this.screen
        });
      }
      this.useDom = _useDom;
    }

    Sprite.prototype.draw = function(id, x, y, divId) {
      var theDiv, _ref1;
      if (!this.useDom) {
        switch (this.type) {
          case "src":
          case "function":
          case "tileset":
            return id.drawImage(this.screen, x, y);
          case "animation":
            return (_ref1 = this.imgs[Math.floor(this.imgInd)]).draw.apply(_ref1, arguments);
        }
      } else {
        theDiv = $(".divSprite" + this.id + ":eq(" + (divId - 1) + ")");
        return theDiv.css({
          left: "" + (x - room.view()[0]) + "px",
          top: "" + (y - room.view()[1]) + "px"
        });
      }
    };

    Sprite.prototype.refreshAnimation = function(isFirst) {
      if (this.type === "animation" && isFirst) {
        return this.imgInd = (this.imgInd + this.speed) % this.imgs.length;
      }
    };

    Sprite.prototype.createDiv = function() {
      var root, thisDiv;
      if (!this.useDom) {
        return;
      }
      thisDiv = $(this.screen).clone(true);
      thisDiv.attr("class", "divSprite" + this.id);
      root = useDom ? game_screen : "body";
      $(root).append(thisDiv);
      $(thisDiv).css({
        position: "absolute"
      });
    };

    return Sprite;

  })();

  Idea.Sprite = Sprite;

  collisionRect = function(a, b) {
    var bottom, left, min, right, top;
    if (!(a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y)) {
      return false;
    }
    top = b.y + b.height - a.y;
    bottom = a.y + a.height - b.y;
    right = a.x + a.width - b.x;
    left = b.x + b.width - a.x;
    min = Math.min(top, bottom, left, right);
    switch (min) {
      case top:
        return "top";
      case bottom:
        return "bottom";
      case right:
        return "right";
      case left:
        return "left";
      default:
        return "top";
    }
  };

  basicFunctionsStart = function() {
    var keyDownHandler, keyUpHandler, mDown, mouseDownHandler, mouseMoveHandler, mouseUpHandler;
    basicFunctionsEnd();
    Idea.globalMouseX = Idea.globalMouseY = 0;
    Idea.globalKeysdown = [];
    Idea.globalMousedown = false;
    mDown = [];
    $(game_screen).contextmenu(function() {
      return false;
    }).dblclick(function(e) {
      return false;
    });
    mouseMoveHandler = function(e) {
      Idea.globalMouseX = e.offsetX || e.pageX - $(this).offset().left;
      Idea.globalMouseY = e.offsetY || e.pageY - $(this).offset().top;
      return false;
    };
    mouseDownHandler = function(e) {
      Idea.globalMousepressed = Idea.globalMousedown = e.which === 3 ? "right" : "left";
      return false;
    };
    mouseUpHandler = function(e) {
      Idea.globalMousedown = false;
      Idea.globalMouseup = e.which === 3 ? "right" : "left";
      return false;
    };
    keyDownHandler = function(e) {
      var d, p, w;
      d = Idea.globalKeysdown;
      p = Idea.globalKeyspressed;
      w = e.which;
      if (__indexOf.call(d, w) < 0) {
        d.push(w);
      }
      if (!(__indexOf.call(p, w) >= 0 || __indexOf.call(mDown, w) >= 0)) {
        p.push(w);
        mDown.push(w);
      }
      return false;
    };
    keyUpHandler = function(e) {
      var d, u, w;
      d = Idea.globalKeysdown;
      u = Idea.globalKeysup;
      w = e.which;
      mDown.splice(mDown.indexOf(w), 1);
      if (__indexOf.call(u, w) < 0) {
        u.push(w);
      }
      d.splice(d.indexOf(w), 1);
      return false;
    };
    controls.mouseControls(mouseDownHandler, mouseUpHandler, mouseMoveHandler);
    controls.keyControls(keyDownHandler, keyUpHandler);
  };

  basicFunctionsEnd = function() {
    Idea.globalKeysup = [];
    Idea.globalKeyspressed = [];
    Idea.globalMousepressed = Idea.globalMouseup = false;
  };

  Idea.math = math = {
    distance: function(x1, y1, x2, y2) {
      var _ref1, _ref2, _ref3;
      if ($.type(x1) === "object" && $.type(y1) === "object") {
        _ref1 = [x1.x, x1.y, y1.x, y1.y], x1 = _ref1[0], y1 = _ref1[1], x2 = _ref1[2], y2 = _ref1[3];
      } else if ($.type(x1) === "object" && $.type(y1) === "number" && $.type(x2) === "number") {
        _ref2 = [x1.x, x1.y, y1, x2], x1 = _ref2[0], y1 = _ref2[1], x2 = _ref2[2], y2 = _ref2[3];
      } else if ($.type(x1) === "number" && $.type(y1) === "number" && $.type(x2) === "object") {
        _ref3 = [x1, y1, x2.x, x2.y], x1 = _ref3[0], y1 = _ref3[1], x2 = _ref3[2], y2 = _ref3[3];
      }
      return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    },
    intersect: function(x1, y1, w1, h1, x2, y2, w2, h2) {
      var obj1, obj2, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      if ($.type(x1) === "object" && $.type(y1) === "object") {
        _ref1 = [x1, y1], obj1 = _ref1[0], obj2 = _ref1[1];
      }
      if ($.type(x1) === "object" && ((($.type(y1) === (_ref4 = $.type(w1)) && _ref4 === (_ref3 = $.type(h1))) && _ref3 === (_ref2 = $.type(x2))) && _ref2 === "number")) {
        obj1 = x1;
        obj2 = {
          x: y1,
          y: w1,
          width: h1,
          height: x2
        };
      }
      if (((($.type(x1) === (_ref7 = $.type(y1)) && _ref7 === (_ref6 = $.type(w1))) && _ref6 === (_ref5 = $.type(h1))) && _ref5 === "number") && $.type(x2) === "object") {
        obj1 = {
          x: x1,
          y: y1,
          width: w1,
          height: h1
        };
        obj2 = x2;
      }
      if ($.type(x1) === "number" && $.type(h2) === "number") {
        obj1 = {
          x: x1,
          y: y1,
          width: w1,
          height: h1
        };
        obj2 = {
          x: x2,
          y: y2,
          width: w2,
          height: h2
        };
      }
      return collisionRect(obj1, obj2);
    }
  };

  Idea.allRooms = allRooms = [];

  Room = (function() {
    function Room(args) {
      var backPic, repeating, _ref1, _ref2, _ref3, _ref4, _ref5;
      if (args == null) {
        args = {};
      }
      _ref5 = [args.persistent, args.background, args.backPic, (_ref1 = args.width) != null ? _ref1 : gameWidth != null ? gameWidth : 0, (_ref2 = args.height) != null ? _ref2 : gameHeight != null ? gameHeight : 0, (_ref3 = args.repeating) != null ? _ref3 : true, (_ref4 = args.useBackCanvas) != null ? _ref4 : true], this.persistent = _ref5[0], this.background = _ref5[1], backPic = _ref5[2], this.w = _ref5[3], this.h = _ref5[4], repeating = _ref5[5], this.useBackCanvas = _ref5[6];
      this.toDestroy = [];
      this.following = {};
      this.roomToGoTo = false;
      this.allInstances = [];
      this.staticInst = [];
      this.deactivated = [];
      allRooms.push(this);
      this.id = allRooms.length - 1;
      this.dynamic = [];
      this.trx = 0;
      this["try"] = 0;
      this.renderBackPic = function() {
        var largePic, that;
        this.largeBackPics = this.w > gameWidth * 9 && this.h > gameHeight * 9 && (backPic != null);
        if (this.largeBackPics && (backPic != null) && !useDom) {
          largePic = new Image();
          this.smallCan = [];
          that = this;
          largePic.onload = function() {
            var c, ch, column, ctx, cw, n, row, _i, _j, _ref6, _ref7;
            for (row = _i = 0, _ref6 = largePic.width; gameWidth > 0 ? _i < _ref6 : _i > _ref6; row = _i += gameWidth) {
              n = that.smallCan.length;
              that.smallCan.push([]);
              for (column = _j = 0, _ref7 = largePic.height; gameHeight > 0 ? _j < _ref7 : _j > _ref7; column = _j += gameHeight) {
                c = document.createElement('canvas');
                c.width = gameWidth;
                c.height = gameHeight;
                ctx = c.getContext('2d');
                cw = row + gameWidth > this.width ? this.width - row : gameWidth;
                ch = column + gameHeight > this.height ? this.height - column : gameHeight;
                ctx.drawImage(this, row, column, cw, ch, 0, 0, cw, ch);
                that.smallCan[n].push(c);
              }
            }
          };
          if (repeating) {
            return new Sprite(backPic, this.w, this.h, repeating, function() {
              return largePic.src = this.c.toDataURL();
            });
          }
        } else if (backPic != null) {
          return this.backPic = new Sprite({
            source: backPic,
            width: this.w,
            height: this.h,
            repeating: repeating
          });
        }
      };
    }

    Room.prototype.refreshBackground = function() {
      var ceiledx, ceiledy, ctx, flooredx, flooredy, ind, insideView, inst, insts, newFunct, obj, roomBar, useBackCanvas, v, _i, _j, _len, _len1, _ref1, _ref2;
      if (this.useBackCanvas) {
        useBackCanvas = backgroundCanvas;
        ctx = useBackCanvas.getContext("2d");
        if (this.background != null) {
          ctx.fillStyle = this.background;
          ctx.fillRect(0, 0, useBackCanvas.width, useBackCanvas.height);
        } else if (this.backPic != null) {
          if (!this.largeBackPics) {
            ctx.drawImage(this.backPic.screen, Math.min(this.trx, this.w - gameWidth), Math.min(this["try"], this.h - gameHeight), useBackCanvas.width, useBackCanvas.height, 0, 0, useBackCanvas.width, useBackCanvas.height);
          } else {
            v = room.view();
            if (v[0] % gameWidth === 0 && v[1] % gameHeight === 0) {
              ctx.drawImage(this.smallCan[v[0] / gameWidth][v[1] / gameHeight], v[0], v[1]);
            } else {
              flooredx = Math.floor(v[0] / gameWidth);
              ceiledx = Math.ceil(v[0] / gameWidth);
              flooredy = Math.floor(v[1] / gameHeight);
              ceiledy = Math.ceil(v[1] / gameHeight);
              ctx.drawImage(this.smallCan[flooredx][flooredy], flooredx * gameWidth - v[0], flooredy * gameHeight - v[1]);
              ctx.drawImage(this.smallCan[flooredx][ceiledy], flooredx * gameWidth - v[0], ceiledy * gameHeight - v[1]);
              ctx.drawImage(this.smallCan[ceiledx][flooredy], ceiledx * gameWidth - v[0], flooredy * gameHeight - v[1]);
              ctx.drawImage(this.smallCan[ceiledx][ceiledy], ceiledx * gameWidth - v[0], ceiledy * gameHeight - v[1]);
            }
          }
        }
        newFunct = function() {
          var evalArray;
          evalArray = function() {
            var args, caller, fns, i, _i, _len, _results;
            fns = arguments[0], caller = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
            switch ($.type(fns)) {
              case "function":
                return fns.apply(caller, args);
              case "array":
                _results = [];
                for (_i = 0, _len = fns.length; _i < _len; _i++) {
                  i = fns[_i];
                  _results.push(i.apply(caller, args));
                }
                return _results;
                break;
              default:
                return false;
            }
          };
          if ((this.draw != null) && this.useBackCan) {
            ctx.save();
            ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
            ctx.rotate(this.imgAngle * Math.PI / 180);
            ctx.translate(-(this.x + this.width / 2), -(this.y + this.height / 2));
            ctx.translate(-room.trx, -room["try"]);
            evalArray(this.draw, this, ctx);
            return ctx.restore();
          }
        };
        _ref1 = this.staticInst;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          inst = _ref1[_i];
          newFunct.call(inst);
        }
        roomBar = (function() {
          v = room.view();
          return {
            x: v[0],
            y: v[1],
            width: gameWidth,
            height: gameHeight
          };
        })();
        _ref2 = this.deactivated;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          inst = _ref2[_j];
          if (!inst) {
            continue;
          }
          insideView = collisionRect(inst.mask(), roomBar);
          if (insideView) {
            obj = inst.constructor;
            ind = this.deactivated.indexOf(inst);
            this.deactivated.splice(ind, 1);
            if (inst.sprite.useDom) {
              $(".divSprite" + inst.sprite.id + ":eq(" + (inst.id - 1) + ")").css("display", "block");
            }
            insts = Idea(obj, this);
            insts.push(inst);
          }
        }
      }
    };

    Room.prototype.refresh = function(ctx) {
      var alarm, f, i, inst, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref1, _ref2, _ref3;
      if (ctx == null) {
        ctx = useDom ? game_screen : game_screen.getContext('2d');
      }
      if (((this.background == null) || this.useBackCanvas) && !useDom) {
        ctx.clearRect(0, 0, room.w, room.h);
      } else if (((this.background != null) && !this.useBackCanvas) && !useDom) {
        ctx.fillStyle = this.background;
        ctx.fillRect(0, 0, room.w, room.h);
      } else if (this.background && useDom) {
        $(game_screen).css("background-color", this.background);
      }
      if (!(this.useBackCanvas || useDom)) {
        ctx.translate(-this.trx, -this["try"]);
        if ((_ref1 = this.backPic) != null) {
          if (typeof _ref1.draw === "function") {
            _ref1.draw(game_screen.getContext('2d'), 0, 0);
          }
        }
        ctx.restore();
      }
      if (!$.isEmptyObject(this.following)) {
        f = this.following;
        if (f.instance.y >= room.view()[1] + gameHeight - (f.borderY + f.instance.height) && room.view()[1] < room.h - gameHeight) {
          room.view(0, f.speedY);
        }
        if (f.instance.y <= room.view()[1] + f.borderY && room.view()[1] > 0) {
          room.view(0, -f.speedY);
        }
        if (f.instance.x >= room.view()[0] + gameWidth - (f.borderX + f.instance.width) && room.view()[0] < room.w - gameWidth) {
          room.view(f.speedX, 0);
        }
        if (f.instance.x <= room.view()[0] + f.borderX && room.view()[0] > 0) {
          room.view(-f.speedX, 0);
        }
      }
      for (_i = 0, _len = alarms.length; _i < _len; _i++) {
        alarm = alarms[_i];
        if ((alarm != null ? alarm.value : void 0) > 0 && --alarm.value === 0) {
          alarm.value = -1;
          alarm.trigger();
        }
      }
      if (!useDom) {
        ctx.save();
        ctx.translate(-this.trx, -this["try"]);
      }
      _ref2 = room.allInstances;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        i = _ref2[_j];
        for (_k = 0, _len2 = i.length; _k < _len2; _k++) {
          inst = i[_k];
          if (inst != null) {
            if (typeof inst.events === "function") {
              inst.events();
            }
          }
        }
      }
      if (!useDom) {
        ctx.restore();
      }
      _ref3 = this.toDestroy;
      for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
        inst = _ref3[_l];
        inst.destroy(false);
      }
      this.toDestroy = [];
      if (this.roomToGoTo) {
        roomGoto(this.roomToGoTo, false);
        this.roomToGoTo = false;
      }
    };

    Room.prototype.view = function(mx, my, relative) {
      var viewX, viewY, _ref1;
      if (mx == null) {
        mx = 0;
      }
      if (my == null) {
        my = 0;
      }
      if (relative == null) {
        relative = true;
      }
      _ref1 = [this.trx, this["try"]], viewX = _ref1[0], viewY = _ref1[1];
      if (relative) {
        this.trx += mx;
        this["try"] += my;
      } else {
        this.trx = mx;
        this["try"] = my;
      }
      if (!((relative && mx === 0 && my === 0) || (!relative && mx === viewX && my === viewY))) {
        if (typeof this.refreshBackground === "function") {
          this.refreshBackground();
        }
      }
      return [this.trx, this["try"]];
    };

    Room.prototype.follow = function(instance, borderX, borderY, speedX, speedY) {
      this.following.instance = instance;
      this.following.borderX = borderX;
      this.following.borderY = borderY;
      this.following.speedX = speedX;
      this.following.speedY = speedY;
    };

    return Room;

  })();

  Idea.Room = Room;

  Idea.roomGoto = roomGoto = function(newRoom, toBuffer, callback) {
    var i, inst, prevRoom, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref1, _ref2;
    if (toBuffer == null) {
      toBuffer = settings.bufferRoomGoto;
    }
    if (toBuffer && (room != null)) {
      room.roomToGoTo = newRoom;
      switch (newRoom) {
        case "next":
          return allRooms[room.id + 1];
        case "previous":
          return allRooms[room.id - 1];
        default:
          return newRoom;
      }
    }
    prevRoom = room;
    if (prevRoom != null) {
      _ref1 = prevRoom.allInstances;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        i = _ref1[_i];
        for (_j = 0, _len1 = i.length; _j < _len1; _j++) {
          inst = i[_j];
          if (typeof inst.roomEnd === "function") {
            inst.roomEnd();
          }
        }
      }
      $("div[class^='divSprite']").remove();
      if (!prevRoom.persistent) {
        prevRoom.allInstances = new InstanceArray();
        for (_k = 0, _len2 = allObjects.length; _k < _len2; _k++) {
          i = allObjects[_k];
          prevRoom.allInstances.push([]);
        }
      }
    }
    switch (newRoom) {
      case "next":
        room = allRooms[room.id + 1];
        break;
      case "previous":
        room = allRooms[room.id - 1];
        break;
      default:
        room = newRoom;
    }
    if (typeof room.create === "function") {
      room.create();
    }
    if (typeof room.refreshBackground === "function") {
      room.refreshBackground();
    }
    _ref2 = room.allInstances;
    for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
      i = _ref2[_l];
      for (_m = 0, _len4 = i.length; _m < _len4; _m++) {
        inst = i[_m];
        if (typeof inst.roomStart === "function") {
          inst.roomStart();
        }
      }
    }
    return room;
  };

  Idea.getRoom = function() {
    return room;
  };

  window["Idea"] = Idea;

}).call(this);
